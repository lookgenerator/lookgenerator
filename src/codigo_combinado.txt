

=== Archivo: .\app\globals.css ===

@tailwind base;
@tailwind components;
@tailwind utilities;

/* Variables CSS personalizadas */
:root {
  --background: #ffffff;
  --foreground: #171717;
}

@media (prefers-color-scheme: dark) {
  :root {
    --background: #0a0a0a;
    --foreground: #ededed;
  }
}

body {
  background: var(--background);
  color: var(--foreground);
  font-family: Arial, Helvetica, sans-serif;
}

.perspective {
  perspective: 1000px;
}
.backface-hidden {
  backface-visibility: hidden;
}

.scrollbar-hide::-webkit-scrollbar {
  display: none;
}
.scrollbar-hide {
  -ms-overflow-style: none;
  scrollbar-width: none;
}

@keyframes expandFlip {
  0% {
    transform: scale(0.6) rotateY(-90deg);
    opacity: 0;
  }
  100% {
    transform: scale(1) rotateY(0deg);
    opacity: 1;
  }
}

@keyframes collapseFlip {
  0% {
    transform: scale(1) rotateY(0deg);
    opacity: 1;
  }
  100% {
    transform: scale(0.6) rotateY(90deg);
    opacity: 0;
  }
}

.animate-expandFlip {
  animation: expandFlip 0.6s ease-out forwards;
}

.animate-collapseFlip {
  animation: collapseFlip 0.6s ease-in forwards;
}

@keyframes pulseBackground {
  0% {
    opacity: 0.6;
    transform: scale(1);
  }
  100% {
    opacity: 0.8;
    transform: scale(1.05);
  }
}

@keyframes fadeIn {
  from { opacity: 0; transform: translateY(10px); }
  to { opacity: 1; transform: translateY(0); }
}
@keyframes fadeOut {
  from { opacity: 1; transform: translateY(0); }
  to { opacity: 0; transform: translateY(-10px); }
}

.animate-fadeIn {
  animation: fadeIn 0.8s ease-out forwards;
}
.animate-fadeOut {
  animation: fadeOut 0.6s ease-in forwards;
}

html, body {
  height: 100%;
  overflow-x: hidden;
}

.preserve-3d { transform-style: preserve-3d; }

=== Archivo: .\app\layout.tsx ===

import type { Metadata } from "next";
import { Geist, Geist_Mono } from "next/font/google";
import "./globals.css";

const geistSans = Geist({
  variable: "--font-geist-sans",
  subsets: ["latin"],
});

const geistMono = Geist_Mono({
  variable: "--font-geist-mono",
  subsets: ["latin"],
});

export const metadata: Metadata = {
  title: "Asistente Virtual - El Corte Ingl√©s",
  description: "Chatbot de recomendaci√≥n de productos personalizado.",
};

export default function RootLayout({
  children,
}: Readonly<{
  children: React.ReactNode;
}>) {
  return (
    <html lang="en">
      <body
        className={`${geistSans.variable} ${geistMono.variable} antialiased`}
      >
        {children}
      </body>
    </html>
  );
}


=== Archivo: .\app\page.tsx ===

import Chat from './components/Chat'

export default function Home() {
  return <Chat />
}


=== Archivo: .\app\api\env-check\route.ts ===

import { NextResponse } from "next/server";

export const runtime = "nodejs";
export const dynamic = "force-dynamic";
export const revalidate = 0;

type ErrorLike = { name?: string; message?: string };
function normalizeError(err: unknown): Required<ErrorLike> {
  if (err instanceof Error) return { name: err.name || "Error", message: err.message || "Unknown" };
  if (typeof err === "object" && err !== null) {
    const o = err as Record<string, unknown>;
    return {
      name: typeof o.name === "string" ? o.name : "Error",
      message: typeof o.message === "string" ? o.message : "Unknown",
    };
  }
  return { name: "Error", message: String(err) };
}

async function readOpenAIKeyFromSSM(): Promise<string> {
  // Import din√°mico para empaquetar solo en server
  const { SSMClient, GetParameterCommand } = await import("@aws-sdk/client-ssm");
  const client = new SSMClient({
    region: process.env.AWS_REGION || process.env.AWS_DEFAULT_REGION || "eu-west-1",
  });
  const name = process.env.OPENAI_API_KEY_PARAM || "/secrets/OPENAI_API_KEY";
  const out = await client.send(new GetParameterCommand({ Name: name, WithDecryption: true }));
  return out.Parameter?.Value ?? "";
}

export async function GET() {
  try {
    const key = await readOpenAIKeyFromSSM();
    return NextResponse.json({ ok: true, source: "ssm", has_OPENAI: key.length > 0 });
  } catch (err: unknown) {
    const e = normalizeError(err);
    return NextResponse.json(
      {
        ok: false,
        source: "ssm",
        error: e.name,
        message: e.message,
        hint:
          "Si ves Cannot find module ‚Üí falta @aws-sdk/client-ssm en dependencies. " +
          "Si ves AccessDeniedException ‚Üí falta permiso ssm:GetParameter/kms:Decrypt en el role SSR.",
      },
      { status: 500 }
    );
  }
}


=== Archivo: .\app\api\llm\route.ts ===

import { NextResponse } from 'next/server'
import OpenAI from 'openai'
import { generateGreeting } from './handlers/greetingHandler'
import { generateAuthGreeting } from './handlers/authGreetingHandler'

console.log('‚ö°Ô∏è /api/llm ROUTE ejecut√°ndose en servidor...')

const client = new OpenAI({
  apiKey: process.env.OPENAI_API_KEY!,
})

export async function POST(req: Request) {
  try {
    const { message } = await req.json()

    const prompt = `
Eres un clasificador de intenciones para un chatbot de e-commerce.
Tu √∫nica salida debe ser un JSON v√°lido con el formato:
{"intent": "...", "entities": {...}}

Intenciones posibles:
- identificar_usuario ‚Üí cuando el usuario escribe un n√∫mero de cliente (ej: "soy 12345")
- ver_mas_producto ‚Üí cuando pide ver m√°s detalles de un producto
- recomendaciones_producto ‚Üí cuando pide recomendaciones iguales a un producto
- buscar_por_descripcion ‚Üí cuando quiere buscar algo por descripci√≥n (ej: "buscar zapatillas rojas")
- saludo ‚Üí cuando el usuario saluda (ej: "hola", "buenas")
- desconocido ‚Üí si no encaja con nada

Ejemplos:
Usuario: "hola"  
Respuesta: {"intent":"saludo","entities":{}}

Usuario: "soy el cliente 12345"  
Respuesta: {"intent":"identificar_usuario","entities":{"customer_id":"12345"}}

Usuario: "buscar zapatillas rojas"  
Respuesta: {"intent":"buscar_por_descripcion","entities":{"descripcion":"zapatillas rojas"}}

Mensaje del usuario: "${message}"
`

    const completion = await client.chat.completions.create({
      model: process.env.MODEL || 'no asignado',
      messages: [{ role: 'user', content: prompt }],
      temperature: 0,
    })

    const raw = completion.choices[0].message?.content?.trim() || '{}'

    let parsed
    try {
      parsed = JSON.parse(raw)
    } catch {
      console.error('‚ùå No se pudo parsear:', raw)
      parsed = { intent: 'desconocido', entities: {} }
    }

    // 2Ô∏è‚É£ --- SI ES UN SALUDO, GENERAMOS RESPUESTA PERSONALIZADA ---
    if (parsed.intent === 'saludo') {
      const greeting = await generateGreeting(message)
      return NextResponse.json({
        intent: parsed.intent,
        response: greeting,
        entities: parsed.entities,
      })
    }
    // 2Ô∏è‚É£ --- SI ES IDENTIFICACI√ìN DE USUARIO, GENERAMOS SALLUDO PERSONALIZADO ---
    if (
      parsed.intent === 'identificar_usuario' &&
      parsed.entities?.customer_id
    ) {
      const customerName = parsed.entities?.customer_name || ''
      const greeting = await generateAuthGreeting(customerName)

      return NextResponse.json({
        intent: parsed.intent,
        response: greeting,
        entities: parsed.entities,
      })
    }

    return NextResponse.json(parsed)
  } catch (err) {
    console.error('‚ùå Error en /api/llm:', err)
    return NextResponse.json(
      { intent: 'desconocido', entities: {}, error: 'internal' },
      { status: 500 }
    )
  }
}


=== Archivo: .\app\api\llm\auth-greeting\route.ts ===

import { NextResponse } from "next/server";
import { generateAuthGreeting } from "../handlers/authGreetingHandler";

export async function POST(req: Request) {
  try {
    const { customerName } = await req.json();

    if (!customerName) {
      return NextResponse.json(
        { response: null, error: "customerName required" },
        { status: 400 }
      );
    }

    const greeting = await generateAuthGreeting(customerName);

    return NextResponse.json({ response: greeting });
  } catch (err) {
    console.error("‚ùå Error en /api/llm/auth-greeting:", err);
    return NextResponse.json({ response: null }, { status: 500 });
  }
}


=== Archivo: .\app\api\llm\generate-look\route.ts ===

// app/api/llm/generate-look/route.ts

import { NextResponse } from "next/server";
import OpenAI from "openai";
import { apiFetch } from "@/app/lib/api/client";
import type { ProductFilter } from "@/app/lib/types/product";

const client = new OpenAI({
  apiKey: process.env.OPENAI_API_KEY!,
});

// üß† Cache de valores de cat√°logo
let cachedValues: Record<string, string[]> | null = null;
let lastFetchTime = 0;
const CACHE_TTL = 1000 * 60 * 60 * 6; // 6 horas

async function getCachedValues() {
  const now = Date.now();
  if (cachedValues && now - lastFetchTime < CACHE_TTL) return cachedValues;

  console.log("‚ôªÔ∏è Refrescando valores de cat√°logo...");
  try {
    const [colours, categories, subcategories, articletype, genders, usages, seasons] =
      await Promise.all([
        apiFetch<{ values: string[] }>("/products/values/basecolour"),
        apiFetch<{ values: string[] }>("/products/values/mastercategory"),
        apiFetch<{ values: string[] }>("/products/values/subcategory"),
        apiFetch<{ values: string[] }>("/products/values/articletype"),
        apiFetch<{ values: string[] }>("/products/values/gender"),
        apiFetch<{ values: string[] }>("/products/values/usage"),
        apiFetch<{ values: string[] }>("/products/values/season"),
      ]);

    cachedValues = {
      basecolour: colours.values,
      mastercategory: categories.values,
      subcategory: subcategories.values,
      articletype: articletype.values,
      gender: genders.values,
      usage: usages.values,
      season: seasons.values,
    };
    lastFetchTime = now;
  } catch (err) {
    console.error("‚ùå Error al obtener valores de cat√°logo:", err);
    cachedValues = {
      basecolour: ["Black", "White", "Blue", "Red", "Beige"],
      mastercategory: ["Apparel", "Accessories", "Footwear"],
      subcategory: ["Tshirt", "Jeans", "Shoes", "Bag", "Watch"],
      articletype: ["Belts", "Jeans", "Watches"],
      gender: ["Men", "Women", "Unisex"],
      usage: ["Casual", "Formal", "Sports"],
      season: ["Summer", "Winter", "All"],
    };
  }

  return cachedValues!;
}

// üé≤ Selecciona un producto aleatorio
function randomItem<T>(arr: T[]): T | null {
  if (!arr || arr.length === 0) return null;
  const idx = Math.floor(Math.random() * arr.length);
  return arr[idx];
}

export async function POST(req: Request) {
  try {
    const { productName, category, baseProduct } = await req.json();
    if (!productName) {
      return NextResponse.json(
        { error: "El nombre del producto es obligatorio" },
        { status: 400 }
      );
    }

    const values = await getCachedValues();
    const randomSeed = Math.floor(Math.random() * 10000);

    // üß† Prompt de generaci√≥n del look
    const prompt = `
Eres un estilista digital de El Corte Ingl√©s.
Tu tarea es generar un look completo (2‚Äì4 art√≠culos) a partir del producto base. No recomiendes un art√≠culo de la misma categor√≠a que el producto base.

Producto base:
- Nombre: "${productName}"
- Categor√≠a: "${category || "sin especificar"}"

Usa solo valores v√°lidos del cat√°logo:
- basecolour: ${values.basecolour.slice(0, 15).join(", ")}
- mastercategory: ${values.mastercategory.slice(0, 20).join(", ")}
- subcategory: ${values.subcategory.slice(0, 20).join(", ")}
- articletype: ${values.articletype.slice(0, 20).join(", ")}
- gender: ${values.gender.join(", ")}
- usage: ${values.usage.join(", ")}
- season: ${values.season.join(", ")}

Devuelve solo JSON con este formato:
{
  "estilo": "...",
  "descripcion_general": "...",
  "articulos": [
    {
      "tipo": "...",
      "nombre_sugerido": "...",
      "filtros": {
        "gender": "...",
        "mastercategory": "...",
        "subcategory": "...",
        "articletype": "...",
        "basecolour": "...",
        "usage": "...",
        "season": "..."
      }
    }
  ]
}
Semilla creativa: ${randomSeed}.
`;

    const completion = await client.chat.completions.create({
      model: process.env.MODEL || "gpt-4o-mini",
      messages: [{ role: "system", content: prompt }],
      temperature: 1,
      max_tokens: 600,
    });

    const content = completion.choices[0].message?.content?.trim() || "{}";
    console.log("üßæ RAW LLM OUTPUT:\n", content);

    // Intentar parsear JSON
    let parsed: {
      estilo: string;
      descripcion_general: string;
      articulos?: {
        tipo: string;
        nombre_sugerido: string;
        filtros?: Record<string, string>;
        producto?: ProductFilter | null;
      }[];
    };
    try {
      parsed = JSON.parse(content);
    } catch {
      parsed = { estilo: "Desconocido", descripcion_general: content, articulos: [] };
    }

    // üß© Buscar productos reales
    for (const art of parsed.articulos || []) {
      if (!art.filtros) continue;

      const filtrosActuales = { ...art.filtros };
      let results: ProductFilter[] = [];

      // üî¢ Orden de importancia
      const importancia = [
        "gender",
        "mastercategory",
        "subcategory",
        "articletype",
        "basecolour",
        "usage",
        "season",
      ];

      console.log(`üéØ Buscando producto para: ${art.nombre_sugerido}`);
      console.log("Filtros iniciales:", filtrosActuales);

      // üîÅ Reducir progresivamente los filtros seg√∫n importancia
      while (results.length === 0 && Object.keys(filtrosActuales).length > 0) {
        const query = new URLSearchParams({ ...filtrosActuales, limit: "10" }).toString();
        const productos = await apiFetch<ProductFilter[]>(`/products/filter?${query}`);

        if (productos.length > 0) {
          results = productos;
          console.log(`‚úÖ ${productos.length} productos encontrados.`);
          break;
        }

        // Eliminar el filtro menos importante que quede activo
        const filtrosActivos = Object.keys(filtrosActuales);
        const menosImportante = importancia
          .slice()
          .reverse()
          .find(key => filtrosActivos.includes(key));

        if (menosImportante) {
          console.log(`‚ö†Ô∏è Sin resultados. Eliminando filtro: ${menosImportante}`);
          delete filtrosActuales[menosImportante as keyof typeof filtrosActuales];
        } else {
          console.log("‚ö†Ô∏è No quedan filtros para eliminar.");
          break;
        }
      }

      // üß© Fallback final si a√∫n no hay resultados
      if (results.length === 0) {
        console.warn("‚ö†Ô∏è Fallback final: sin resultados, usando productos aleatorios.");
        const randoms = await apiFetch<ProductFilter[]>("/products/filter?limit=10");
        results = randoms;
      }

      // üé≤ Elegir uno aleatorio
      const elegido = results.length > 0 ? randomItem(results) : null;
      art.producto = elegido;

      console.log(
        `üéØ Producto final para "${art.nombre_sugerido}":`,
        elegido ? elegido.name : "Ninguno encontrado"
      );
    }

    // üß† NUEVA FASE: Generar justificaci√≥n del look
    const productosFinales = [
      ...(baseProduct ? [baseProduct] : []),
      ...(parsed.articulos?.map(a => a.producto).filter(Boolean) || []),
    ];

    const resumenProductos = productosFinales
      .map(
        p =>
          `- ${p.name} (${p.category || "sin categor√≠a"})`
      )
      .join("\n");

    const promptJustificacion = `
Eres un estilista digital profesional.
Analiza este conjunto de productos y genera una breve justificaci√≥n est√©tica (m√°x. 3 frases)
explicando por qu√© forman un look coherente, mencionando estilo, colores o sensaciones.

Productos seleccionados:
${resumenProductos}

Devuelve solo el texto, sin comillas ni formato adicional.
`;

    const justific = await client.chat.completions.create({
      model: process.env.MODEL || "gpt-4o-mini",
      messages: [{ role: "system", content: promptJustificacion }],
      temperature: 0.8,
      max_tokens: 100,
    });

    const justificacion =
      justific.choices[0].message?.content?.trim() ||
      "Este look equilibra estilo, confort y armon√≠a visual en sus combinaciones.";

    const finalResponse = {
      estilo: parsed.estilo,
      descripcion_general: parsed.descripcion_general,
      justificacion,
      productos_finales: productosFinales,
    };


    console.log("‚úÖ LOOK FINAL CON JUSTIFICACION:", JSON.stringify(finalResponse, null, 2));
    return NextResponse.json(finalResponse);
  } catch (err) {
    console.error("‚ùå Error en /api/llm/generate-look:", err);
    return NextResponse.json({ error: "Error interno del servidor" }, { status: 500 });
  }
}


=== Archivo: .\app\api\llm\handlers\authGreetingHandler.ts ===

import OpenAI from "openai";

const client = new OpenAI({
  apiKey: process.env.OPENAI_API_KEY!,
});

export async function generateAuthGreeting(customerName: string) {
  const randomSeed = Math.floor(Math.random() * 10000);

  const prompt = `
Eres un asistente virtual amable de una tienda online.
Tu tarea es generar un mensaje de bienvenida cuando un cliente se autentica.
Debe sonar c√°lido, personalizado y diferente cada vez.
Incluye el nombre del cliente si est√° disponible ("${customerName}").

Var√≠a el estilo, y las frases para que no se repitan.

Ejemplos:
- "¬°Hola ${customerName}! Me alegra verte de nuevo"
- "¬°Bienvenida otra vez, ${customerName}! ¬øLista para descubrir novedades?"
- "¬°Hey ${customerName}! Qu√© gusto volver a verte"
- "¬°Encantado de verte, ${customerName}! Te he preparado recomendaciones personalizadas"

No incluyas comillas ni texto adicional ni iconos. Solo devuelve el saludo.
Semilla de variaci√≥n: ${randomSeed}
`;

  const completion = await client.chat.completions.create({
    model: process.env.MODEL || "gpt-4o-mini",
    messages: [{ role: "system", content: prompt }],
    temperature: 1,
    top_p: 1,
    presence_penalty: 0.6,
    frequency_penalty: 0.5,
    max_tokens: 80,
  });

  const greeting = completion.choices[0].message?.content?.trim();
  return greeting || `¬°Hola ${customerName}! Encantado de verte üòä`;
}


=== Archivo: .\app\api\llm\handlers\defaultHandler.ts ===

export async function defaultHandler(message: string) {
  return Response.json({
    intent: "desconocido",
    response: "Perdona, no he entendido bien tu mensaje ü§î. ¬øPodr√≠as reformularlo?",
  });
}


=== Archivo: .\app\api\llm\handlers\greetingHandler.ts ===

import OpenAI from "openai";

const client = new OpenAI({
  apiKey: process.env.OPENAI_API_KEY!,
});

export async function generateGreeting(message: string) {
  const randomSeed = Math.floor(Math.random() * 10000);

  const prompt = `
Eres un asistente virtual amable de una tienda online.
Si el usuario est√° autenticado y el mensaje indica su nombre (ejemplo: "Usuario autenticado: Laura"), debes saludarlo usando su nombre.
Si no hay nombre, genera un saludo general, breve, natural y diferente cada vez.
El saludo debe sonar humano, positivo y cercano.

Var√≠a el estilo y estructura en cada respuesta (usa distintos emojis o frases).

Ejemplos:
- "¬°Hola Laura! Qu√© gusto verte üòä"
- "¬°Buenas, Laura! Encantado de saludarte üëã"
- "¬°Hola! Me alegra verte por aqu√≠ üòÑ"
- "¬°Hey! Espero que est√©s teniendo un gran d√≠a ‚òÄÔ∏è"

Solo devuelve el texto del saludo. No incluyas nada m√°s.
Semilla de variaci√≥n: ${randomSeed}
`;

  const completion = await client.chat.completions.create({
    model: process.env.MODEL || "gpt-4o-mini",
    messages: [
      { role: "system", content: prompt },
      { role: "user", content: message },
    ],
    temperature: 1,
    top_p: 1,
    presence_penalty: 0.6,
    frequency_penalty: 0.5,
    max_tokens: 60,
  });

  const greeting = completion.choices[0].message?.content?.trim();
  return greeting || "¬°Hola! Encantado de saludarte üòä";
}


=== Archivo: .\app\api\llm\ping\route.ts ===

// app/api/llm/ping/route.ts
import OpenAI from "openai";
import { NextResponse } from "next/server";

export const runtime = "nodejs";
export const dynamic = "force-dynamic";
export const revalidate = 0;

type ErrLike = { name?: string; message?: string };
function norm(err: unknown): Required<ErrLike> {
  if (err instanceof Error) return { name: err.name || "Error", message: err.message || "Unknown" };
  if (typeof err === "object" && err !== null) {
    const o = err as Record<string, unknown>;
    return {
      name: typeof o.name === "string" ? o.name : "Error",
      message: typeof o.message === "string" ? o.message : "Unknown",
    };
  }
  return { name: "Error", message: String(err) };
}

async function getOpenAIKey(): Promise<string> {
  // 1) Si en el futuro vuelven a funcionar las env de Amplify, √∫sala primero
  if (process.env.OPENAI_API_KEY) return process.env.OPENAI_API_KEY;

  // 2) Fallback SSM
  const { SSMClient, GetParameterCommand } = await import("@aws-sdk/client-ssm");
  const client = new SSMClient({
    region: process.env.AWS_REGION || process.env.AWS_DEFAULT_REGION || "eu-west-1",
  });
  const name = process.env.OPENAI_API_KEY_PARAM || "/secrets/OPENAI_API_KEY";
  const out = await client.send(new GetParameterCommand({ Name: name, WithDecryption: true }));
  return out.Parameter?.Value ?? "";
}

export async function GET() {
  try {
    const apiKey = await getOpenAIKey();
    if (!apiKey) {
      return NextResponse.json({ ok: false, error: "OPENAI_API_KEY not found (env/SSM)" }, { status: 500 });
    }

    const client = new OpenAI({ apiKey });
    const models = await client.models.list();
    return NextResponse.json({ ok: true, modelCount: models.data?.length ?? 0 });
  } catch (err: unknown) {
    const e = norm(err);
    // √ötil para CloudWatch:
    console.error("[/api/llm/ping] error:", e.name, e.message);
    return NextResponse.json({ ok: false, error: `${e.name}: ${e.message}` }, { status: 500 });
  }
}


=== Archivo: .\app\api\llm\product-description\route.ts ===

// app/api/llm/product-description/route.ts

import { NextResponse } from "next/server";
import OpenAI from "openai";

const client = new OpenAI({
  apiKey: process.env.OPENAI_API_KEY!,
});

export async function POST(req: Request) {
  try {
    const { name, category } = await req.json();

    if (!name) {
      return NextResponse.json(
        { error: "Product name is required" },
        { status: 400 }
      );
    }

    // üé≤ Semilla aleatoria para diversificar el output
    const randomSeed = Math.floor(Math.random() * 10000);

    const prompt = `
Eres un redactor de marketing para la tienda online de El Corte Ingl√©s.
Tu tarea es escribir una descripci√≥n breve, √∫nica y atractiva para un producto.

Detalles del producto:
- Nombre: "${name}"
- Categor√≠a: "${category || "sin especificar"}"

Instrucciones:
- S√© original y evita repetir estructuras comunes.
- Usa un tono natural y persuasivo, distinto cada vez.
- En moda, resalta estilo y sensaciones. 
- En electr√≥nica, resalta innovaci√≥n y utilidad. 
- En hogar o decoraci√≥n, resalta confort y est√©tica.
- Longitud m√°xima: 3 frases (menos de 70 palabras).
- No repitas frases entre productos.
- No uses comillas, emojis ni etiquetas HTML.
- Semilla creativa: ${randomSeed}

Ejemplos de tono:
- ‚ÄúDise√±ado para quienes buscan comodidad y elegancia en su d√≠a a d√≠a.‚Äù
- ‚ÄúTecnolog√≠a avanzada que transforma la forma en que disfrutas tu tiempo libre.‚Äù
- ‚ÄúCombina un estilo moderno con materiales de la m√°s alta calidad.‚Äù

Devuelve solo el texto de la descripci√≥n, sin formato adicional.
`;

    const completion = await client.chat.completions.create({
      model: process.env.MODEL || "gpt-4o-mini",
      messages: [{ role: "system", content: prompt }],
      temperature: 1.1, // üå∂Ô∏è m√°s creatividad
      top_p: 1,
      max_tokens: 100,
      presence_penalty: 0.6, // penaliza repeticiones
      frequency_penalty: 0.5,
    });

    const description = completion.choices[0].message?.content?.trim();

    return NextResponse.json({ description });
  } catch (err) {
    console.error("‚ùå Error generando descripci√≥n:", err);
    return NextResponse.json(
      { error: "Error generando descripci√≥n" },
      { status: 500 }
    );
  }
}


=== Archivo: .\app\api\llm\search-recommendation\route.ts ===

import { NextResponse } from "next/server";
import OpenAI from "openai";
import { apiFetch } from "@/app/lib/api/client";
import type { ProductFilter } from "@/app/lib/types/product";

const client = new OpenAI({ apiKey: process.env.OPENAI_API_KEY! });

// Funci√≥n para obtener similitudes simples
function findSimilarValues(list: string[], target: string, maxCount = 3): string[] {
  if (!target) return [];
  const lower = target.toLowerCase();
  const matches = list.filter(
    (v) =>
      v.toLowerCase() !== lower &&
      (v.toLowerCase().startsWith(lower.slice(0, 2)) ||
        v.toLowerCase().includes(lower.slice(0, 3)))
  );
  if (matches.length === 0) {
    const shuffled = [...list].sort(() => 0.5 - Math.random());
    return shuffled.slice(0, maxCount);
  }
  return matches.slice(0, maxCount);
}

export async function POST(req: Request) {
  try {
    const { descripcion } = await req.json();
    if (!descripcion)
      return NextResponse.json(
        { error: "El campo 'descripcion' es obligatorio." },
        { status: 400 }
      );

    console.log(`üß† Nueva b√∫squeda iterativa controlada para: "${descripcion}"`);

    // 1Ô∏è‚É£ Obtener listas reales desde la API
    const [
      colours,
      categories,
      subcategories,
      usages,
      genders,
      articletype,
      season,
      year,
    ] = await Promise.all([
      apiFetch<{ column: string; values: string[] }>("/products/values/basecolour"),
      apiFetch<{ column: string; values: string[] }>("/products/values/mastercategory"),
      apiFetch<{ column: string; values: string[] }>("/products/values/subcategory"),
      apiFetch<{ column: string; values: string[] }>("/products/values/usage"),
      apiFetch<{ column: string; values: string[] }>("/products/values/gender"),
      apiFetch<{ column: string; values: string[] }>("/products/values/articletype"),
      apiFetch<{ column: string; values: string[] }>("/products/values/season"),
      apiFetch<{ column: string; values: (string | number)[] }>("/products/values/year"),
    ]);

    // 2Ô∏è‚É£ Pedimos al LLM que interprete la descripci√≥n con precisi√≥n
    const interpretPrompt = `
Eres un asistente experto en retail. 
Un usuario ha escrito: "${descripcion}" (puede estar en cualquier idioma).

Tu tarea:
1. Identifica qu√© valores de las listas de productos se ajustan mejor a la descripci√≥n.
2. Usa √∫nicamente los valores listados a continuaci√≥n (no inventes ni traduzcas fuera de ellos).
3. Devuelve un JSON con **m√°ximo dos filtros**, priorizando subcategor√≠a y color si son relevantes.
4. No incluyas texto adicional ni explicaciones.

Valores disponibles:
- basecolour: ${colours.values.join(", ")}
- subcategory: ${subcategories.values.slice(0, 40).join(", ")}
- mastercategory: ${categories.values.join(", ")}
- articletype: ${articletype.values.slice(0, 30).join(", ")}

Ejemplo: {"subcategory":"Gloves","basecolour":"Green"}.
`;

    const interpretation = await client.chat.completions.create({
      model: process.env.MODEL || "gpt-4o-mini",
      messages: [{ role: "system", content: interpretPrompt }],
      temperature: 0.5,
    });

    let filters: Record<string, string> = {};
    try {
      filters = JSON.parse(interpretation.choices[0].message?.content?.trim() || "{}");
    } catch {
      filters = {};
    }

    // Validaci√≥n de seguridad: asegurarse de que los filtros est√°n en las listas reales
    if (
      filters.basecolour &&
      !colours.values.includes(filters.basecolour)
    )
      delete filters.basecolour;

    if (
      filters.subcategory &&
      !subcategories.values.includes(filters.subcategory)
    )
      delete filters.subcategory;

    console.log(`üéØ Filtros iniciales interpretados por el LLM: ${JSON.stringify(filters)}`);

    // Si el LLM no devuelve nada v√°lido, forzar fallback m√≠nimo
    if (Object.keys(filters).length === 0) {
      filters = { subcategory: "Accessories" };
      console.log("‚ö†Ô∏è LLM no devolvi√≥ filtros v√°lidos. Usando fallback gen√©rico.");
    }

    const results: ProductFilter[] = [];
    const usedFilters: Record<string, Record<string, string>> = {};
    let attempts = 0;
    const maxAttempts = 6;

    // 3Ô∏è‚É£ Bucle de b√∫squeda iterativa
    while (results.length < 5 && attempts < maxAttempts) {
      attempts++;
      usedFilters[`Intento ${attempts}`] = { ...filters };

      const query = new URLSearchParams({ ...filters, limit: "15" }).toString();
      const data = await apiFetch<ProductFilter[]>(`/products/filter?${query}`);
      console.log(`üîé Intento ${attempts}: ${JSON.stringify(filters)} ‚Üí ${data.length} resultados`);

      // Acumular resultados sin duplicar
      const newOnes = data.filter(
        (p) => !results.some((r) => r.product_id === p.product_id)
      );
      results.push(...newOnes);
      console.log(`üìà Total acumulado: ${results.length} productos`);

      if (results.length >= 5) break;

      // üé® Probar colores o subcategor√≠as similares
      if (filters.basecolour) {
        const similarColours = findSimilarValues(colours.values, filters.basecolour);
        for (const alt of similarColours) {
          const altFilters = { ...filters, basecolour: alt };
          const q = new URLSearchParams({ ...altFilters, limit: "15" }).toString();
          const altData = await apiFetch<ProductFilter[]>(`/products/filter?${q}`);
          console.log(`üé® Color alternativo ${alt} ‚Üí ${altData.length} resultados`);
          const newAlt = altData.filter(
            (p) => !results.some((r) => r.product_id === p.product_id)
          );
          results.push(...newAlt);
          usedFilters[`Intento ${attempts} (color ${alt})`] = altFilters;
          if (results.length >= 5) break;
        }
      }

      if (results.length >= 5) break;

      if (filters.subcategory) {
        const similarSubcats = findSimilarValues(subcategories.values, filters.subcategory);
        for (const s of similarSubcats) {
          const altFilters = { ...filters, subcategory: s };
          const q = new URLSearchParams({ ...altFilters, limit: "15" }).toString();
          const altData = await apiFetch<ProductFilter[]>(`/products/filter?${q}`);
          console.log(`üß© Subcategor√≠a alternativa ${s} ‚Üí ${altData.length} resultados`);
          const newAlt = altData.filter(
            (p) => !results.some((r) => r.product_id === p.product_id)
          );
          results.push(...newAlt);
          usedFilters[`Intento ${attempts} (subcat ${s})`] = altFilters;
          if (results.length >= 5) break;
        }
      }
    }

    // 4Ô∏è‚É£ Fallback final
    if (results.length < 5) {
      console.warn("‚ö†Ô∏è No se alcanz√≥ el m√≠nimo. Recuperando gen√©ricos.");
      const generic = await apiFetch<ProductFilter[]>("/products/filter?limit=10");
      const extras = generic.filter(
        (p) => !results.some((r) => r.product_id === p.product_id)
      );
      results.push(...extras);
      usedFilters["fallback"] = { fallback: "B√∫squeda sin filtros" };
    }

    // 5Ô∏è‚É£ Explicaci√≥n LLM
    const explainPrompt = `
Resume en una frase por qu√© estos productos coinciden con "${descripcion}".
`;
    const explain = await client.chat.completions.create({
      model: process.env.MODEL || "gpt-4o-mini",
      messages: [{ role: "system", content: explainPrompt }],
      temperature: 0.6,
      max_tokens: 60,
    });

    const explanation =
      explain.choices[0].message?.content?.trim() ||
      `He encontrado ${results.length} productos relacionados con "${descripcion}".`;

    return NextResponse.json({
      count: results.length,
      filters_used: usedFilters,
      results: results.slice(0, 10),
      explanation,
    });
  } catch (err) {
    console.error("‚ùå Error en /api/llm/search-recommendation:", err);
    return NextResponse.json({ error: "Error interno del servidor" }, { status: 500 });
  }
}


=== Archivo: .\app\api\llm\welcome-message\route.ts ===

// app/api/llm/welcome-message/route.ts
import { NextResponse } from "next/server";
import OpenAI from "openai";

const client = new OpenAI({
  apiKey: process.env.OPENAI_API_KEY!,
});

export async function GET() {
  try {
    const randomSeed = Math.floor(Math.random() * 10000);

    const prompt = `
Eres el asistente virtual de El Corte Ingl√©s.
Debes generar un mensaje de bienvenida breve, profesional y sin emojis.

Instrucciones:
- El mensaje debe sonar natural, cercano y humano.
- Indica de forma clara que el usuario puede:
  1. Buscar un producto escribiendo su descripci√≥n.
  2. Identificarse como cliente indicando su n√∫mero de cliente.
- No uses emojis ni signos decorativos.
- S√© directo (m√°ximo 2 frases).
- Genera peque√±as variaciones entre ejecuciones usando la semilla ${randomSeed}.

Ejemplo:
"Hola, soy el asistente virtual de El Corte Ingl√©s. Puedes buscar un producto escribiendo su descripci√≥n o identificarte con tu n√∫mero de cliente."
`;

    const completion = await client.chat.completions.create({
      model: process.env.MODEL || "gpt-4o-mini",
      messages: [{ role: "system", content: prompt }],
      temperature: 0.8,
      max_tokens: 80,
    });

    const message =
      completion.choices[0].message?.content?.trim() ||
      "Hola, soy el asistente virtual de El Corte Ingl√©s. Puedes buscar un producto escribiendo su descripci√≥n o identificarte con tu n√∫mero de cliente.";

    return NextResponse.json({ message });
  } catch (err) {
    console.error("‚ùå Error en /api/llm/welcome-message:", err);
    return NextResponse.json(
      {
        message:
          "Hola, soy el asistente virtual de El Corte Ingl√©s. Puedes buscar un producto escribiendo su descripci√≥n o identificarte con tu n√∫mero de cliente.",
      },
      { status: 500 }
    );
  }
}


=== Archivo: .\app\components\Chat.tsx ===

'use client'
import { useState, useRef, useEffect } from 'react'
import Image from 'next/image'
import Message from './Message'
import InputBox from './InputBox'
import TypingIndicator from './TypingIndicator'
import useDarkMode from '../hooks/useDarkMode'
import { Moon, Sun } from 'lucide-react'
import { getSimilarProducts } from '../lib/api/products'
import type { MessageItem, ChatProduct } from '../lib/types/chat'
import { getCustomerById } from '../lib/api/client'
import type { Customer } from '../lib/types/customer'
import { User } from 'lucide-react'
import { detectIntent } from '../lib/api/llm'
import type { ProductFilter } from '@/app/lib/types/product'
import type { LookArticle, LookResponse } from "@/app/lib/types/looks"

export default function Chat() {
  const [messages, setMessages] = useState<MessageItem[]>([])
  const chatRef = useRef<HTMLDivElement>(null)
  const [customer, setCustomer] = useState<Customer | null>(null)
  const [isLoading, setIsLoading] = useState(false)
  const inputRef = useRef<HTMLInputElement>(null)

  useEffect(() => {
    if (!isLoading) {
      inputRef.current?.focus()
    }
  }, [isLoading])

  const handleSend = async (msg: string) => {
    setMessages(prev => [...prev, { role: 'user', text: msg }])

    setIsLoading(true)

    try {
      const { intent, entities, response } = await detectIntent(
        customer
          ? `Usuario autenticado: ${customer.first_name}. Mensaje: ${msg}`
          : msg
      )

      // üîé DEBUG solo si NEXT_PUBLIC_DEBUG = "true"
      if (process.env.NEXT_PUBLIC_DEBUG === 'true') {
        setMessages(prev => [
          ...prev,
          {
            role: 'bot',
            text: `üõ†Ô∏è Debug ‚Üí Intent: **${intent}** | Entities: ${JSON.stringify(
              entities
            )}| Response: ${JSON.stringify(response)}`,
          },
        ])
      }

      switch (intent) {
        case 'saludo':
          const name = customer?.first_name ? ` ${customer.first_name}` : ''
          setMessages(prev => [
            ...prev,
            {
              role: 'bot',
              text: response
                ? response
                : `üëã ¬°Hola${name}! ¬øEn qu√© puedo ayudarte hoy?`,
            },
          ])
          break

        case 'identificar_usuario':
          if (entities.customer_id) {
            try {
              const customer = await getCustomerById(
                String(entities.customer_id)
              )
              setCustomer(customer)

              // üîπ Generar saludo LLM de bienvenida personalizada
              const res = await fetch('/api/llm/auth-greeting', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                  customerName: customer.first_name,
                }),
              })
              const { response: authGreeting } = await res.json()

              //console.log('authGreeting ', authGreeting)

              setMessages(prev => [
                ...prev,
                {
                  role: 'bot',
                  text:
                    authGreeting ||
                    `¬°Hola ${customer.first_name}! Bienvenido üëã`,
                },
              ])

              if (customer.products && customer.products.length > 0) {
                const baseProduct = customer.products[0]

                // üîπ Nueva llamada: descripci√≥n generada por el LLM
                const descRes = await fetch('/api/llm/product-description', {
                  method: 'POST',
                  headers: { 'Content-Type': 'application/json' },
                  body: JSON.stringify({
                    name: baseProduct.name,
                  }),
                })
                const descData = await descRes.json()

                setMessages(prev => [
                  ...prev,
                  {
                    role: 'bot',
                    text: `Como has comprado o visualizado ${baseProduct.name}, voy a buscarte recomendaciones similares. `,
                    product: {
                      id: baseProduct.product_id,
                      name: baseProduct.name,
                      image_url: baseProduct.image_url,
                      description:
                        descData.description ||
                        'Este es un producto destacado dentro de nuestro cat√°logo. Pr√≥ximamente aqu√≠ aparecer√° una descripci√≥n generada autom√°ticamente por el asistente inteligente.',
                    },
                  },
                ])

                const data = await getSimilarProducts(baseProduct.product_id)

                // Generar descripci√≥n para el primer producto similar
                const enrichedProducts = await Promise.all(
                  data.neighbors.map(async p => {
                    try {
                      const r = await fetch('/api/llm/product-description', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                          name: p.name,
                        }),
                      })
                      const d = await r.json()
                      return {
                        id: p.product_id,
                        name: p.name,
                        image_url: p.image_url,
                        score: p.score,
                        description:
                          d.description ||
                          'Descripci√≥n no disponible en este momento.',
                      }
                    } catch {
                      return {
                        id: p.product_id,
                        name: p.name,
                        image_url: p.image_url,
                        score: p.score,
                        description:
                          'Descripci√≥n no disponible por el momento.',
                      }
                    }
                  })
                )

                setMessages(prev => [
                  ...prev,
                  {
                    role: 'bot',
                    text: `Productos similares a ${baseProduct.name}:`,
                    products: enrichedProducts,
                  },
                ])
              }
            } catch (err) {
              setMessages(prev => [
                ...prev,
                {
                  role: 'bot',
                  text: `‚ùå No se encontr√≥ un cliente con ese ID. (${err})`,
                },
              ])
            }
          }
          break

        case 'ver_mas_producto':
          setMessages(prev => [
            ...prev,
            {
              role: 'bot',
              text: "Aqu√≠ ir√≠a la l√≥gica de 'ver m√°s producto' üîç",
            },
          ])
          break

        case 'recomendaciones_producto':
          setMessages(prev => [
            ...prev,
            {
              role: 'bot',
              text: 'Aqu√≠ ir√≠a la l√≥gica para dar recomendaciones de producto üí°',
            },
          ])
          break

        case 'buscar_por_descripcion':
          try {
            const descripcion = entities.descripcion as string

            // üß† mensaje inicial
            setMessages(prev => [
              ...prev,
              {
                role: 'bot',
                text: `Buscando productos que coincidan con: "${descripcion}" üîé`,
              },
            ])

            // üîç Llamada al nuevo endpoint inteligente de b√∫squeda
            const res = await fetch('/api/llm/search-recommendation', {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({ descripcion }),
            })

            if (!res.ok) {
              throw new Error(
                `Error en /api/llm/search-recommendation: ${res.status}`
              )
            }

            const { results, explanation } = await res.json()

            if (!results || results.length === 0) {
              setMessages(prev => [
                ...prev,
                {
                  role: 'bot',
                  text: `No he encontrado productos que coincidan con "${descripcion}". üòî`,
                },
              ])
              break
            }

            // ‚ú® Enriquecer cada producto con una descripci√≥n generada por el LLM
            const enrichedProducts = await Promise.all(
              results.slice(0, 5).map(async (p: ProductFilter) => {
                try {
                  const descRes = await fetch('/api/llm/product-description', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                      name: p.name,
                      category: p.category,
                    }),
                  })

                  const descData = await descRes.json()

                  return {
                    id: p.product_id,
                    name: p.name,
                    image_url: p.image_url,
                    category: p.category,
                    description:
                      descData.description ||
                      'Descripci√≥n no disponible en este momento.',
                  }
                } catch (err) {
                  console.error('‚ùå Error generando descripci√≥n:', err)
                  return {
                    id: p.product_id,
                    name: p.name,
                    image_url: p.image_url,
                    category: p.category,
                    description: 'Descripci√≥n no disponible.',
                  }
                }
              })
            )

            // üó£Ô∏è Mensaje explicativo del LLM
            setMessages(prev => [
              ...prev,
              {
                role: 'bot',
                text:
                  explanation ||
                  'He encontrado algunos art√≠culos que podr√≠an interesarte üëá',
              },
            ])

            // üõçÔ∏è Mostrar los productos encontrados en carrusel
            setMessages(prev => [
              ...prev,
              {
                role: 'bot',
                text: '',
                products: enrichedProducts,
              },
            ])
          } catch (err) {
            console.error('‚ùå Error procesando b√∫squeda por descripci√≥n:', err)
            setMessages(prev => [
              ...prev,
              {
                role: 'bot',
                text: 'Ha ocurrido un error al procesar tu b√∫squeda. Int√©ntalo de nuevo m√°s tarde.',
              },
            ])
          }

          break

        default:
          setMessages(prev => [
            ...prev,
            { role: 'bot', text: 'No entend√≠ la petici√≥n ü§î' },
          ])
      }
    } catch (err) {
      console.error('Error detectando intenci√≥n:', err)
      setMessages(prev => [
        ...prev,
        { role: 'bot', text: '‚ùå Error procesando tu mensaje.' },
      ])
    } finally {
      setIsLoading(false)
    }
  }

  useEffect(() => {
    chatRef.current?.scrollTo({
      top: chatRef.current.scrollHeight,
      behavior: 'smooth',
    })
  }, [messages])

  const [darkMode, setDarkMode] = useDarkMode()

  const formatCustomerId = (id: string) => {
    return `600833......${id.padStart(7, '0')}`
  }

  // üëã Pantalla de bienvenida
  const [showIntro, setShowIntro] = useState(true)
  const [fadeOut, setFadeOut] = useState(false)

  const handleStart = async () => {
    setFadeOut(true)

    // Espera a que se desvanezca la intro
    setTimeout(async () => {
      setShowIntro(false)

      // üî∏ Muestra indicador de escritura
      setIsLoading(true)

      try {
        // Llamada al LLM
        const res = await fetch('/api/llm/welcome-message')
        const data = await res.json()

        // Simular un peque√±o retardo para realismo
        setTimeout(() => {
          setIsLoading(false)
          setMessages([
            {
              role: 'bot',
              text: data.message,
            },
          ])
        }, 1000)
      } catch (err) {
        console.error('‚ùå Error obteniendo saludo inicial:', err)
        setIsLoading(false)
        setMessages([
          {
            role: 'bot',
            text: 'Hola, soy el asistente virtual de El Corte Ingl√©s. Puedes buscar un producto escribiendo su descripci√≥n o identificarte con tu n√∫mero de cliente.',
          },
        ])
      }
    }, 700) // ‚è±Ô∏è tiempo sincronizado con el fadeOut
  }

  const handleFindSimilar = async (product: ChatProduct) => {
    // 1Ô∏è‚É£ Mensaje inicial
    setMessages(prev => [
      ...prev,
      {
        role: 'bot',
        text: `Buscando productos similares a ${product.name} üîé`,
        product,
      },
    ])

    setIsLoading(true)

    // 3Ô∏è‚É£ Obtener productos similares desde la API
    const data = await getSimilarProducts(product.id)

    // 4Ô∏è‚É£ Enriquecer descripciones
    const enriched = await Promise.all(
      data.neighbors.map(async p => {
        try {
          const r = await fetch('/api/llm/product-description', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
              name: p.name,
            }),
          })
          const d = await r.json()
          return {
            id: p.product_id,
            name: p.name,
            image_url: p.image_url,
            score: p.score,
            description:
              d.description || 'Descripci√≥n no disponible por el momento.',
          }
        } catch {
          return {
            id: p.product_id,
            name: p.name,
            image_url: p.image_url,
            score: p.score,
            description: 'Descripci√≥n no disponible.',
          }
        }
      })
    )

    setIsLoading(false)

    // 5Ô∏è‚É£ Mostrar lista de similares
    setMessages(prev => [
      ...prev,
      {
        role: 'bot',
        text: `Productos similares a ${product.name}:`,
        products: enriched,
      },
    ])
  }

const handleGenerateLook = async (product: ChatProduct) => {
  // üß© 1Ô∏è‚É£ Mensaje inicial
  setMessages(prev => [
    ...prev,
    {
      role: "bot",
      text: `‚ú® Generando look sugerido para el producto "${product.name}"...`,
      product,
    },
  ])

  setIsLoading(true)

  try {
    // üß† 2Ô∏è‚É£ Llamada al nuevo endpoint con producto base incluido
    const res = await fetch("/api/llm/generate-look", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({
        productName: product.name,
        category: product.category,
        baseProduct: {
          product_id: product.id,
          name: product.name,
          image_url: product.image_url,
          category: product.category,
        },
      }),
    })

    if (!res.ok) throw new Error("Error al generar el look")

    const data = await res.json()
    console.log("üé® LOOK COMPLETO:", data)

    // üßæ 3Ô∏è‚É£ Mostrar la descripci√≥n general y art√≠culos complementarios
    const formatFilters = (filters?: Record<string, string>) => {
      if (!filters) return ""
      return Object.entries(filters)
        .filter(([_, v]) => v && v !== "...")
        .map(([k, v]) => `‚Ä¢ ${k}: ${v}`)
        .join(", ")
    }

    const textResult = `
üß• **Estilo sugerido:** ${data.estilo || "No especificado"}  
‚ú® ${data.descripcion_general || "Sin descripci√≥n."}

üëó **Art√≠culos complementarios:**  
${
  data.articulos?.length
    ? data.articulos
        .map(
          (a: LookArticle, i: number) => `
${i + 1}. **${a.tipo}**  
${a.nombre_sugerido}
${a.filtros ? formatFilters(a.filtros) : ""}
`
        )
        .join("\n")
    : "No disponibles"
}
`
  //  setMessages(prev => [...prev, { role: "bot", text: textResult }])


    // üõçÔ∏è 5Ô∏è‚É£ Mostrar todos los productos del look (base + complementarios)
    const productosFinales = (data.productos_finales || []).map((p: ProductFilter) => ({
      id: p.product_id,
      name: p.name,
      image_url: p.image_url,
      category: p.category || "",
      description: data.estilo || "",
    }))

    if (productosFinales.length > 0) {
      setMessages(prev => [
        ...prev,
        {
          role: "bot",
          text: `${data.justificacion}`,
          products: productosFinales,
        },
      ])
    }
  } catch (err) {
    console.error("‚ùå Error generando look:", err)
    setMessages(prev => [
      ...prev,
      {
        role: "bot",
        text:
          "‚ùå Ocurri√≥ un error al generar el look. Int√©ntalo de nuevo m√°s tarde.",
      },
    ])
  } finally {
    setIsLoading(false)
  }
}


  return (
    <div
      className="
      relative flex items-center justify-center h-screen overflow-hidden
      bg-gradient-to-br from-green-50 via-blue-50 to-white
      dark:from-gray-900 dark:via-gray-800 dark:to-black
    "
    >
      {/* ‚ú® Capa de textura transl√∫cida */}
      <div
        className="
        absolute inset-0 
        bg-[url('https://www.transparenttextures.com/patterns/symphony.png')] 
        dark:bg-[url('https://www.transparenttextures.com/patterns/black-linen.png')]
        opacity-20 dark:opacity-15
        pointer-events-none
      "
      />

      {/* üí´ Capa de luces difusas */}
      <div
        className="
        absolute inset-0 
        bg-[radial-gradient(circle_at_top_left,_#22c55e40,_transparent_60%),radial-gradient(circle_at_bottom_right,_#2563eb40,_transparent_60%)]
        dark:bg-[radial-gradient(circle_at_top_left,_#22c55e55,_transparent_60%),radial-gradient(circle_at_bottom_right,_#1e3a8a55,_transparent_60%)]
        animate-pulseBackground blur-[2px]
        pointer-events-none
      "
      />

      {/* üí¨ Contenedor principal del chat */}
      <div
        className="
  relative z-10 flex flex-col w-full max-w-md h-[90vh] sm:h-[850px]
  bg-white/40 dark:bg-gray-800/30
  backdrop-blur-xl
  rounded-2xl shadow-2xl overflow-hidden
  border border-white/30 dark:border-gray-700/50
  transition-all duration-700
  mx-2 sm:mx-0
"
      >
        {/* Header */}
        <div className="flex items-center gap-3 p-4 bg-blue-600 text-white shadow-md dark:bg-blue-700">
          <Image
            src="https://upload.wikimedia.org/wikipedia/commons/0/02/Logo_Corte_Ingl%C3%A9s.svg"
            alt="El Corte Ingl√©s"
            width={40}
            height={40}
            className="rounded"
          />
          <h1 className="flex-1 text-2xl font-extrabold tracking-tight">
            Asistente Virtual
          </h1>

          {/* Cliente identificado */}
          {customer && (
            <div className="flex flex-col items-end text-sm">
              <div className="flex items-center gap-2">
                <span className="bg-white/20 p-1 rounded-full">
                  <User size={16} />
                </span>
                <span className="font-semibold">
                  {customer.first_name} {customer.last_name}
                </span>
              </div>
              <span className="text-xs opacity-80">
                {formatCustomerId(customer.customer_id)}
              </span>
            </div>
          )}
          <button
            onClick={() => setDarkMode(!darkMode)}
            className="p-2 rounded-full hover:bg-green-500/20 transition"
          >
            {darkMode ? <Sun size={20} /> : <Moon size={20} />}
          </button>

          {/* üßπ Bot√≥n limpiar cach√©, visible solo en modo debug */}
          {process.env.NEXT_PUBLIC_DEBUG === 'true' && (
            <button
              onClick={() => {
                const confirmClear = confirm(
                  '¬øSeguro que quieres borrar todas las descripciones LLM guardadas?'
                )
                if (confirmClear) {
                  const keys = Object.keys(localStorage).filter(k =>
                    k.startsWith('product_desc_')
                  )
                  keys.forEach(k => localStorage.removeItem(k))
                  alert(`üßπ Cach√© LLM eliminada (${keys.length} items)`)
                }
              }}
              className="ml-2 bg-white/20 text-xs px-2 py-1 rounded hover:bg-white/30 transition"
            >
              Limpiar cach√© LLM
            </button>
          )}
        </div>

        {/* Chat body */}
        <div
          ref={chatRef}
          className="
    flex-1 overflow-y-auto p-4
    bg-white/20 dark:bg-gray-900/20
    backdrop-blur-md
    transition-all duration-500
  "
          style={{
            background:
              'linear-gradient(to bottom right, rgba(255,255,255,0.3), rgba(200,255,200,0.1))',
          }}
        >
          {messages.map((m, i) => (
            <Message
              key={i}
              role={m.role}
              text={m.text}
              product={m.product}
              products={m.products}
              onFindSimilar={handleFindSimilar}
              onGenerateLook={handleGenerateLook}
            />
          ))}

          {isLoading && (
            <div className="flex justify-start">
              <div className="px-3 py-2 rounded-lg bg-gray-200 dark:bg-gray-700">
                <TypingIndicator />
              </div>
            </div>
          )}
        </div>

        {/* Input */}
        <InputBox
          onSend={handleSend}
          disabled={isLoading}
          inputRef={inputRef}
        />

        {/* üåü Pantalla de bienvenida */}
        {showIntro && (
          <div
            className={`
      absolute inset-0 z-50 flex flex-col items-center justify-center
      bg-white/80 dark:bg-gray-900/90 backdrop-blur-lg text-center
      transition-opacity duration-700
      ${fadeOut ? 'opacity-0' : 'opacity-100'}
    `}
          >
            <div className="max-w-sm p-6 rounded-2xl shadow-lg bg-white/70 dark:bg-gray-800/80 border border-white/20 dark:border-gray-700">
              <h2 className="text-2xl font-bold mb-2 text-green-700 dark:text-green-400">
                ¬°Bienvenido!
              </h2>

              <p className="text-gray-700 dark:text-gray-300 mb-3">
                Soy el <strong>Asistente Virtual de El Corte Ingl√©s</strong>
              </p>

              {/* üü¢ Logo El Corte Ingl√©s */}
              <div className="flex justify-center mb-5">
                <Image
                  src="https://upload.wikimedia.org/wikipedia/commons/0/02/Logo_Corte_Ingl%C3%A9s.svg"
                  alt="Logo El Corte Ingl√©s"
                  width={130}
                  height={50}
                  className="drop-shadow-md dark:brightness-90"
                />
              </div>

              <div className="text-sm text-gray-600 dark:text-gray-400 mb-6 space-y-2 text-left">
                <p className="flex items-center gap-2">
                  <User
                    size={16}
                    className="text-green-600 dark:text-green-400"
                  />
                  <span>üÜî Identif√≠cate escribiendo tu n√∫mero de cliente.</span>
                </p>
                <p>üîé Busca un producto escribiendo su descripci√≥n.</p>
                <p>üí° Ejemplo: ‚ÄúBuscar zapatillas rojas‚Äù.</p>
              </div>

              <button
                onClick={handleStart}
                className="bg-green-600 hover:bg-green-700 text-white px-6 py-2 rounded-lg shadow transition-all duration-300"
              >
                Comenzar
              </button>
            </div>
          </div>
        )}
      </div>
    </div>
  )
}


=== Archivo: .\app\components\InputBox.tsx ===

"use client";
import { useState } from "react";

type Props = {
  onSend: (msg: string) => void;
  disabled?: boolean;
  inputRef?: React.RefObject<HTMLInputElement | null>;
};

export default function InputBox({ onSend, disabled=false, inputRef }: Props) {
  const [text, setText] = useState("");
  
  return (
    <form
      onSubmit={(e) => {
        e.preventDefault();
        if (!text.trim()) return;
        onSend(text);
        setText("");
      }}
      className="flex gap-2 p-3 border-t bg-white dark:bg-gray-800 dark:border-gray-700 sticky bottom-0 w-full"
    >
      <input
        ref={inputRef}
        className="flex-1 p-2 text-sm sm:text-base border rounded-xl focus:outline-none focus:ring-2 focus:ring-green-500 dark:bg-gray-700 dark:text-white dark:border-gray-600"
        value={text}
        onChange={(e) => setText(e.target.value)}
        placeholder="Escribe un mensaje..."
        disabled={disabled}
      />
      <button
        className="bg-green-500 hover:bg-green-600 text-white px-4 py-2 rounded-xl transition"
        disabled={disabled}
      >
        ‚û§
      </button>
    </form>
  );
}


=== Archivo: .\app\components\Message.tsx ===

import { User, Bot } from 'lucide-react'
import type { ChatProduct } from '../lib/types/chat'
import ProductCard from './ProductCard'
import SimilarProductsCarousel from "./SimilarProductsCarousel";

interface Props {
  role: "user" | "bot";
  text: string;
  product?: ChatProduct;
  products?: ChatProduct[]; // üëà importante
  onFindSimilar?: (product: ChatProduct) => void;
  onGenerateLook?: (product: ChatProduct) => void;
}

export default function Message({ role, text, product, products,onFindSimilar, onGenerateLook }: Props){
   console.log("Message props:", { text, product, products });
  const isUser = role === 'user'

  return (
    <div
      className={`flex items-end gap-2 mb-3 ${
        isUser ? 'justify-end' : 'justify-start'
      }`}
    >
      {!isUser && (
        <div className="w-8 h-8 flex items-center justify-center rounded-full bg-gray-300">
          <Bot size={18} />
        </div>
      )}

      <div
        className={`px-4 py-2 rounded-2xl shadow max-w-[75%] ${
          isUser
            ? 'bg-green-500 text-white rounded-br-none'
            : 'bg-gray-200 text-gray-900 rounded-bl-none dark:bg-gray-700 dark:text-gray-100'
        }`}
      >
        <p className="mb-2">{text}</p>

        {product && <ProductCard product={product} onFindSimilar={onFindSimilar} onGenerateLook={onGenerateLook}/>}

        {/* m√∫ltiples productos */}
        {/* Grid de varios productos */}
        {products && <SimilarProductsCarousel products={products} onFindSimilar={onFindSimilar} onGenerateLook={onGenerateLook}/>}
      </div>

      {isUser && (
        <div className="w-8 h-8 flex items-center justify-center rounded-full bg-green-500 text-white">
          <User size={18} />
        </div>
      )}
    </div>
  )
}


=== Archivo: .\app\components\ProductCard.tsx ===

'use client'
import { useState, useRef } from 'react'
import { createPortal } from 'react-dom'
import type { ChatProduct } from '../lib/types/chat'

function DescriptionWithFade({ text }: { text: string }) {
  const [isAtEnd, setIsAtEnd] = useState(false)
  const scrollRef = useRef<HTMLDivElement>(null)

  const handleScroll = () => {
    if (scrollRef.current) {
      const { scrollTop, scrollHeight, clientHeight } = scrollRef.current
      setIsAtEnd(scrollTop + clientHeight >= scrollHeight - 2)
    }
  }

  return (
    <div className="relative group h-full overflow-hidden">
      <div
        ref={scrollRef}
        onScroll={handleScroll}
        className="text-sm md:text-base text-gray-700 dark:text-gray-200 overflow-y-auto px-1 pr-2
                   scrollbar-thin scrollbar-thumb-gray-400 dark:scrollbar-thumb-gray-500 scrollbar-track-transparent
                   [scrollbar-width:none] group-hover:[scrollbar-width:thin]"
      >
        {text}
      </div>
      {!isAtEnd && (
        <div
          className="pointer-events-none absolute bottom-0 left-0 w-full h-8 
                        bg-gradient-to-t from-white to-transparent dark:from-gray-900"
        />
      )}
    </div>
  )
}

function ExpandedCard({
  product,
  description,
  loadingDesc,
  onBack,
  isSimilar,
  onFindSimilar,
  onGenerateLook
}: {
  product: ChatProduct
  description: string
  loadingDesc: boolean
  onBack: () => void
  isSimilar: boolean
  onFindSimilar?: (product: ChatProduct) => void
  onGenerateLook?: (product: ChatProduct) => void
}) {
  return createPortal(
    <div className="fixed inset-0 z-50 flex items-center justify-center bg-black/60 backdrop-blur-sm">
      <div
        id="expanded-card"
        className="relative flex flex-col w-[90%] max-w-md h-[85%] bg-white dark:bg-gray-800 rounded-2xl shadow-2xl overflow-hidden
                   transform transition-transform duration-700 ease-[cubic-bezier(0.22,1,0.36,1)]
                   animate-expandFlip"
      >
        {/* Cabecera con imagen y datos */}
        <div className="flex-shrink-0 flex flex-col items-center p-5 border-b dark:border-gray-700">
          {/* üîπ C√≥digo del producto en la esquina superior derecha */}
          <div
            className="absolute top-3 right-4 bg-gray-100/80 dark:bg-gray-700/60 text-gray-800 dark:text-gray-200 text-xs px-2 py-1 rounded-md shadow-sm select-none"
            title="C√≥digo del producto"
          >
            ID: {product.id}
          </div>
          <img
            src={
              product.image_url ||
              'https://img.freepik.com/vector-premium/no-hay-foto-disponible-icono-vectorial-simbolo-imagen-predeterminado-imagen-proximamente-sitio-web-o-aplicacion-movil_87543-10615.jpg'
            }
            alt={product.name}
            onError={e => {
              const target = e.currentTarget
              target.src =
                'https://img.freepik.com/vector-premium/no-hay-foto-disponible-icono-vectorial-simbolo-imagen-predeterminado-imagen-proximamente-sitio-web-o-aplicacion-movil_87543-10615.jpg'
            }}
            className="w-full h-64 object-contain mb-4 transition-all duration-500 ease-out"
          />
          <h3 className="font-semibold text-xl mb-1 text-gray-900 dark:text-gray-100 text-center">
            {product.name}
          </h3>
          {product.category && (
            <p className="text-sm text-gray-600 dark:text-gray-400 mb-1">
              Categor√≠a: {product.category}
            </p>
          )}
          {product.score !== undefined && (
            <p className="text-xs text-gray-500 italic">
              Similitud: {product.score.toFixed(3)}%
            </p>
          )}
        </div>

        {/* Descripci√≥n ocupando casi todo el espacio restante */}
        <div className="flex-1 p-5 overflow-y-auto text-base leading-relaxed">
          {loadingDesc ? (
            <div className="flex justify-center items-center h-full gap-1 text-gray-400">
              <span className="w-3 h-3 bg-gray-400 rounded-full animate-bounce"></span>
              <span className="w-3 h-3 bg-gray-400 rounded-full animate-bounce [animation-delay:150ms]"></span>
              <span className="w-3 h-3 bg-gray-400 rounded-full animate-bounce [animation-delay:300ms]"></span>
            </div>
          ) : (
            <p className="text-gray-700 dark:text-gray-200 text-justify">
              {description}
            </p>
          )}
        </div>

        {/* Bot√≥n siempre visible abajo */}
        <div className="flex-shrink-0 p-4 border-t dark:border-gray-700 bg-white/80 dark:bg-gray-800/80 backdrop-blur-sm flex gap-3">
          <button
            onClick={onBack}
            className="flex-1 bg-gray-700 hover:bg-gray-800 text-white px-4 py-2 rounded-md transition-colors"
          >
            Volver
          </button>
          <button
            className="flex-1 bg-blue-600 hover:bg-blue-700 text-white px-4 py-2 rounded-md transition-colors"
            onClick={() => {
              onBack()
              onGenerateLook?.(product)
            }}
          >
            Generar look
          </button>
          {isSimilar && (
            <button
              className="flex-1 bg-green-600 hover:bg-green-700 text-white px-4 py-2 rounded-md transition-colors"
              onClick={() => {
                onBack()
                onFindSimilar?.(product)
              }}
            >
              Buscar similares
            </button>
          )}
        </div>
      </div>
    </div>,
    document.body
  )
}

export default function ProductCard({
  product,
  isSimilar = false,
  onFindSimilar,
  onGenerateLook
}: {
  product: ChatProduct
  isSimilar?: boolean
  onFindSimilar?: (product: ChatProduct) => void
  onGenerateLook?: (product: ChatProduct) => void
}) {
  const [expanded, setExpanded] = useState(false)
  const [loadingDesc, setLoadingDesc] = useState(false)
  const [description, setDescription] = useState(
    product.description ??
      'Descripci√≥n gen√©rica del producto. Aqu√≠ aparecer√° informaci√≥n extendida cuando se conecte el LLM.'
  )

  async function handleViewMore() {
    setExpanded(true)
    const cacheKey = `product_desc_${product.id}`
    const cached = localStorage.getItem(cacheKey)
    if (cached) return setDescription(cached)

    try {
      setLoadingDesc(true)
      const res = await fetch('/api/llm/product-description', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          name: product.name,
          category: product.category,
        }),
      })
      const data = await res.json()
      const desc = data.description || 'No se pudo generar una descripci√≥n.'
      setDescription(desc)
      localStorage.setItem(cacheKey, desc)
    } catch {
      setDescription('‚ùå Error generando descripci√≥n.')
    } finally {
      setLoadingDesc(false)
    }
  }

  const handleBack = () => {
    const card = document.getElementById('expanded-card')
    if (card) {
      card.classList.remove('animate-expandFlip')
      card.classList.add('animate-collapseFlip')
      setTimeout(() => setExpanded(false), 550)
    } else {
      setExpanded(false)
    }
  }

  return (
    <>
      <div className="relative w-36 h-56 sm:w-48 sm:h-64 transition-all duration-500 ease-in-out hover:scale-[1.02]">
        <div className="absolute inset-0 flex flex-col items-center justify-between rounded-xl shadow-md bg-white dark:bg-gray-800 overflow-hidden">
          <img
            src={
              product.image_url ||
              'https://img.freepik.com/vector-premium/no-hay-foto-disponible-icono-vectorial-simbolo-imagen-predeterminado-imagen-proximamente-sitio-web-o-aplicacion-movil_87543-10615.jpg'
            }
            alt={product.name}
            onError={e => {
              const target = e.currentTarget
              target.src =
                'https://img.freepik.com/vector-premium/no-hay-foto-disponible-icono-vectorial-simbolo-imagen-predeterminado-imagen-proximamente-sitio-web-o-aplicacion-movil_87543-10615.jpg'
            }}
            className="w-full h-32 object-contain"
          />
          <div className="p-2 text-center">
            <div className="font-bold text-xs sm:text-sm text-gray-900 dark:text-gray-100 line-clamp-2">
              {product.name}
            </div>
            {product.score !== undefined && (
              <div className="mt-1 text-xs text-gray-500">
                Similitud: {product.score.toFixed(3)}%
              </div>
            )}
            <button
              className="mt-2 bg-green-600 text-white px-3 py-1 rounded-md text-xs hover:bg-green-700 transition-colors"
              onClick={handleViewMore}
            >
              Ver m√°s
            </button>
          </div>
        </div>
      </div>

      {expanded && (
        <ExpandedCard
          product={product}
          description={description}
          loadingDesc={loadingDesc}
          onBack={handleBack}
          isSimilar={isSimilar}
          onFindSimilar={onFindSimilar}
          onGenerateLook={onGenerateLook}
        />
      )}
    </>
  )
}


=== Archivo: .\app\components\SimilarProductsCarousel.tsx ===

'use client'
import { useCallback, useEffect } from 'react'
import useEmblaCarousel from 'embla-carousel-react'
import Autoplay from 'embla-carousel-autoplay'
import { motion } from 'framer-motion'
import ProductCard from './ProductCard'
import type { ChatProduct } from '../lib/types/chat'

export default function SimilarProductsCarousel({
  products,
  onFindSimilar,
  onGenerateLook,
}: {
  products: ChatProduct[]
  onFindSimilar?: (product: ChatProduct) => void
  onGenerateLook?: (product: ChatProduct) => void
}) {
  const autoplay = Autoplay({ delay: 3500, stopOnInteraction: false })
  const [emblaRef, emblaApi] = useEmblaCarousel(
    { align: 'center', loop: true, containScroll: 'trimSnaps' },
    [autoplay]
  )

  const scrollPrev = useCallback(() => emblaApi?.scrollPrev(), [emblaApi])
  const scrollNext = useCallback(() => emblaApi?.scrollNext(), [emblaApi])

  // üß† Pausar/Reanudar desde eventos globales
  useEffect(() => {
    const handlePause = () => autoplay.stop()
    const handleResume = () => autoplay.play()

    window.addEventListener('pauseCarousel', handlePause)
    window.addEventListener('resumeCarousel', handleResume)

    return () => {
      window.removeEventListener('pauseCarousel', handlePause)
      window.removeEventListener('resumeCarousel', handleResume)
    }
  }, [autoplay])

  if (!products?.length) {
    return (
      <p className="text-sm text-gray-500">
        ‚ö†Ô∏è No hay productos similares disponibles.
      </p>
    )
  }

  return (
    <div className="relative w-full mt-4">
      {/* Carrusel principal */}
      <div ref={emblaRef} className="overflow-hidden">
        <div className="flex">
          {products.map((p, i) => (
            <motion.div
              key={p.id}
              className="flex-[0_0_70%] sm:flex-[0_0_40%] md:flex-[0_0_30%] px-3"
              whileHover={{ scale: 1.05, rotateY: 5 }}
              whileTap={{ scale: 0.97 }}
              transition={{ type: 'spring', stiffness: 200, damping: 15 }}
            >
              <motion.div
                className="transform perspective"
                initial={{
                  rotateY: i % 2 === 0 ? -15 : 15,
                  opacity: 0,
                  scale: 0.9,
                }}
                animate={{ rotateY: 0, opacity: 1, scale: 1 }}
                transition={{ duration: 0.8, delay: i * 0.1 }}
              >
                <ProductCard
                  product={p}
                  isSimilar={true}
                  onFindSimilar={onFindSimilar}
                  onGenerateLook={onGenerateLook}
                />
              </motion.div>
            </motion.div>
          ))}
        </div>
      </div>

      {/* Botones de navegaci√≥n */}
      <button
        onClick={scrollPrev}
        className="absolute left-0 top-1/2 -translate-y-1/2 p-2 rounded-full bg-white/70 hover:bg-green-500/80 text-green-700 shadow-md"
      >
        ‚Üê
      </button>
      <button
        onClick={scrollNext}
        className="absolute right-0 top-1/2 -translate-y-1/2 p-2 rounded-full bg-white/70 hover:bg-green-500/80 text-green-700 shadow-md"
      >
        ‚Üí
      </button>
    </div>
  )
}


=== Archivo: .\app\components\SimilarProductsGrid.tsx ===

"use client";
import ProductCard from "./ProductCard";
import type { ChatProduct } from "../lib/types/chat";

export default function SimilarProductsGrid({ products }: { products: ChatProduct[] }) {
  if (!products || products.length === 0) {
    return <p className="text-sm text-gray-500">‚ö†Ô∏è No hay productos similares disponibles.</p>;
  }

  return (
    <div className="grid grid-cols-2 sm:grid-cols-3 md:grid-cols-4 gap-4 mt-2">
      {products.map((p) => (
        <ProductCard key={p.id} product={p} />
      ))}
    </div>
  );
}


=== Archivo: .\app\components\TypingIndicator.tsx ===

// src/app/components/TypingIndicator.tsx
"use client";

export default function TypingIndicator() {
  return (
    <div className="flex gap-1 items-center">
      <span className="w-2.5 h-2.5 bg-gray-500 dark:bg-gray-300 rounded-full animate-bounce"></span>
      <span className="w-2.5 h-2.5 bg-gray-500 dark:bg-gray-300 rounded-full animate-bounce [animation-delay:150ms]"></span>
      <span className="w-2.5 h-2.5 bg-gray-500 dark:bg-gray-300 rounded-full animate-bounce [animation-delay:300ms]"></span>
    </div>
  );
}


=== Archivo: .\app\hooks\useDarkMode.ts ===

"use client";
import { useEffect, useState } from "react";

export default function useDarkMode() {
  const [enabled, setEnabled] = useState(false);

  useEffect(() => {
    if (enabled) {
      document.documentElement.classList.add("dark");
    } else {
      document.documentElement.classList.remove("dark");
    }
  }, [enabled]);

  return [enabled, setEnabled] as const;
}

=== Archivo: .\app\lib\api\auth.ts ===

const API_URL = process.env.NEXT_PUBLIC_API_URL!
const API_USER = process.env.NEXT_PUBLIC_API_USER!
const API_PASSWORD = process.env.NEXT_PUBLIC_API_PASSWORD!

let token: string | undefined

export async function getToken(): Promise<string> {
  if (token) return token // aqu√≠ TS ya sabe que es string

  const res = await fetch(`${API_URL}/auth/token`, {
    method: 'POST',
    headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
    body: new URLSearchParams({
      username: API_USER,
      password: API_PASSWORD,
    }),
  })

  if (!res.ok) {
    const text = await res.text()
    throw new Error(`Failed to fetch token: ${res.status} ${text}`)
  }

  const data = await res.json()
  token = data.access_token as string

  if (!token) throw new Error('No token returned from API')

  return token
}


=== Archivo: .\app\lib\api\client.ts ===

import { getToken } from './auth'
import type { Customer } from "../types/customer";

const API_URL = process.env.NEXT_PUBLIC_API_URL!

export async function apiFetch<T>(
  endpoint: string,
  options: RequestInit = {}
): Promise<T> {
  const token = await getToken()

  const res = await fetch(`${API_URL}${endpoint}`, {
    ...options,
    headers: {
      ...(options.headers || {}),
      Authorization: `Bearer ${token}`,
      'Content-Type': 'application/json',
    },
  })

  if (!res.ok) {
    const text = await res.text()
    throw new Error(`API error: ${res.status} ${text}`)
  }

  return res.json() as Promise<T>
}

export async function getCustomerById(customerId: string): Promise<Customer> {
  return apiFetch<Customer>(`/customers/${customerId}`);
}

=== Archivo: .\app\lib\api\llm.ts ===

// lib/api/llm.ts
export type Intent =
  | "identificar_usuario"
  | "ver_mas_producto"
  | "recomendaciones_producto"
  | "buscar_por_descripcion"
  | "saludo"
  | "desconocido";

export interface IntentResult {
  intent: Intent;
  entities: Record<string, string | number | boolean>;
  response?: string; // ‚Üê a√±adimos el campo opcional generado por el LLM
  error?: string;    // ‚Üê opcional para capturar errores del backend
}

export async function detectIntent(message: string): Promise<IntentResult> {
  const res = await fetch("/api/llm", {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify({ message }),
  });

  if (!res.ok) {
    throw new Error("Error llamando a /api/llm");
  }

  // El backend puede devolver tambi√©n `response`
  const data = await res.json();
  return data as IntentResult;
}


=== Archivo: .\app\lib\api\products.ts ===

import { apiFetch } from "./client";
import type { ProductSingle } from "../types/product";
import type { SimilarProductsResponse } from "../types/product";

export async function getProductById(id: string | number) {
  return apiFetch<ProductSingle>(`/products/single/${id}`);
}

export async function getSimilarProducts(id: string | number) {
  const res = await apiFetch<SimilarProductsResponse>(`/products/similar/${id}`);

  // üîπ Excluir el producto base
  const baseId = res.base_product.product_id;
  const uniqueNeighbors = Array.from(
    new Map(
      res.neighbors
        .filter(n => n.product_id !== baseId)
        .map(n => [n.product_id, n])
    ).values()
  );

  // üîπ Limitar a m√°ximo 10 si quieres consistencia visual
  return {
    ...res,
    neighbors: uniqueNeighbors.slice(0, 10),
  };
}

=== Archivo: .\app\lib\types\chat.ts ===

export type ChatRole = "user" | "bot";

export interface ChatProduct {
  id: number;
  name: string;
  image_url: string;
  category?: string;
  description?:string;
  score?: number;
}

export interface MessageItem {
  role: ChatRole;
  text: string;
  product?: ChatProduct;
  products?: ChatProduct[];
}

=== Archivo: .\app\lib\types\customer.ts ===

export interface Product {
  product_id: number;
  name: string;
  image_url: string;
}

export interface Customer {
  customer_id: string;
  first_name: string;
  last_name: string;
  products: Product[];
}


=== Archivo: .\app\lib\types\looks.ts ===

export interface LookArticle {
  tipo: string;
  nombre_sugerido: string;
  filtros?: {
    mastercategory?: string;
    subcategory?: string;
    articletype?: string;
    basecolour?: string;
    gender?: string;
    usage?: string;
    season?: string;
  };
  producto?: {
    product_id: number;
    name: string;
    image_url: string;
    category?: string;
  } | null;
};

export interface LookResponse {
  estilo: string
  descripcion_general: string
  articulos?: LookArticle[]
}

=== Archivo: .\app\lib\types\product.ts ===

export interface ProductSingle {
  product_id: number;
  name: string;
  category: string;
  image_url: string;
}

export interface ProductNeighbor {
  product_id: number;
  name: string;
  image_url: string;
  score: number;
}

export interface SimilarProductsResponse {
  base_product: {
    product_id: number;
    name: string;
    image_url: string;
  };
  neighbors: ProductNeighbor[];
}

export interface ProductFilter {
  product_id: number;
  name: string;
  category: string;
  image_url: string;
  gender: string;
  mastercategory: string;
  subcategory: string;
  articletype: string;
  basecolour: string;
  season: string;
  year: number;
  usage: string;
}

export interface DistinctValues {
  column: string;
  values: string[];
}

export interface SimilarProductsResponse {
  base_product: {
    product_id: number;
    name: string;
    image_url: string;
  };
  neighbors: ProductNeighbor[];
}

=== Archivo: .\app\test\page.tsx ===

"use client";
import { useEffect, useState } from "react";
import { apiFetch } from "../lib/api/client";

export default function TestPage() {
  const [data, setData] = useState<Record<string, unknown> | null>(null);
  const [error, setError] = useState<string | null>(null);

  useEffect(() => {
    apiFetch<Record<string, unknown>>("/info")
      .then(setData)
      .catch((err) => setError(err.message));
  }, []);

  if (error) return <div className="p-4 text-red-600">Error: {error}</div>;
  if (!data) return <div className="p-4">Cargando...</div>;

  return (
    <pre className="p-4 bg-gray-100 rounded">
      {JSON.stringify(data, null, 2)}
    </pre>
  );
}


=== Archivo: .\app\test\customer\[id]\page.tsx ===

'use client'
import { useEffect, useState } from 'react'
import { useParams } from 'next/navigation'
import { apiFetch } from '../../../lib/api/client'
import type { Customer } from '../../../lib/types/customer'

export default function CustomerPage() {
  const { id } = useParams<{ id: string }>()
  const [customer, setCustomer] = useState<Customer | null>(null)
  const [error, setError] = useState<string | null>(null)

  useEffect(() => {
    if (!id) return
    apiFetch<Customer>(`/customers/${id}`)
      .then(setCustomer)
      .catch(err =>
        setError(err instanceof Error ? err.message : 'Unknown error')
      )
  }, [id])

  if (error) return <div className="p-4 text-red-600">Error: {error}</div>
  if (!customer) return <div className="p-4">Cargando cliente...</div>

  return (
    <div className="p-4 space-y-4">
      <h2 className="text-xl font-bold">
        Cliente: {customer.first_name} {customer.last_name} (ID:{' '}
        {customer.customer_id})
      </h2>

      <h3 className="text-lg font-semibold">Productos:</h3>
      <ul className="grid grid-cols-1 sm:grid-cols-2 gap-4">
        {customer.products.map(p => (
          <li
            key={p.product_id}
            className="border rounded-lg p-3 shadow bg-white dark:bg-gray-800"
          >
            <img
              src={p.image_url}
              alt={p.name}
              className="w-full h-32 object-contain mb-2"
            />
            <p className="font-medium">{p.name}</p>
          </li>
        ))}
      </ul>
    </div>
  )
}


=== Archivo: .\app\test\product\filter\page.tsx ===

"use client";
import { useEffect, useState } from "react";
import { apiFetch } from "../../../lib/api/client";
import type { ProductFilter } from "../../../lib/types/product";

export default function ProductFilterPage() {
  const [products, setProducts] = useState<ProductFilter[]>([]);
  const [error, setError] = useState<string | null>(null);

  // filtros din√°micos
  const filters: Record<string, string> = {
    gender: "Men",
    basecolour: "black",
    limit: "10",
  };

  useEffect(() => {
    async function fetchData() {
      try {
        const query = new URLSearchParams(filters).toString();
        const data = await apiFetch<ProductFilter[]>(`/products/filter?${query}`);
        setProducts(data);
      } catch (err) {
        setError(err instanceof Error ? err.message : "Unknown error");
      }
    }
    fetchData();
  }, []);

  if (error) return <div className="p-4 text-red-600">Error: {error}</div>;
  if (!products.length) return <div className="p-4">Cargando productos...</div>;

  return (
    <div className="p-4 space-y-4 max-w-6xl mx-auto">
      <h2 className="text-2xl font-bold mb-4">Resultados del filtro</h2>
      <div className="grid grid-cols-2 sm:grid-cols-3 md:grid-cols-4 lg:grid-cols-5 gap-4">
        {products.map((p) => (
          <div
            key={p.product_id}
            className="border rounded-lg p-3 shadow bg-white dark:bg-gray-800"
          >
            <img
              src={p.image_url}
              alt={p.name}
              className="w-full h-32 object-contain mb-2"
            />
            <p className="text-sm font-medium">{p.name}</p>
            <p className="text-xs text-gray-500">
              {p.mastercategory} ‚Ä¢ {p.basecolour}
            </p>
            <p className="text-xs text-gray-400">
              {p.season} {p.year} ‚Äî {p.usage}
            </p>
          </div>
        ))}
      </div>
    </div>
  );
}


=== Archivo: .\app\test\product\similar\[id]\page.tsx ===

"use client";
import { useEffect, useState } from "react";
import { useParams } from "next/navigation";
import { apiFetch } from "../../../../lib/api/client";
import type { SimilarProductsResponse } from "../../../../lib/types/product";

export default function SimilarProductsPage() {
  const { id } = useParams<{ id: string }>();
  const [data, setData] = useState<SimilarProductsResponse | null>(null);
  const [error, setError] = useState<string | null>(null);

  useEffect(() => {
    if (!id) return;
    apiFetch<SimilarProductsResponse>(`/products/similar/${id}`)
      .then(setData)
      .catch((err) =>
        setError(err instanceof Error ? err.message : "Unknown error")
      );
  }, [id]);

  if (error) return <div className="p-4 text-red-600">Error: {error}</div>;
  if (!data) return <div className="p-4">Cargando productos similares...</div>;

  return (
    <div className="p-4 space-y-6 max-w-4xl mx-auto">
      {/* Producto base */}
      <div className="text-center">
        <h2 className="text-2xl font-bold mb-2">Producto base</h2>
        <img
          src={data.base_product.image_url}
          alt={data.base_product.name}
          className="w-40 h-40 object-contain mx-auto mb-2"
        />
        <p className="font-medium">{data.base_product.name}</p>
      </div>

      {/* Productos similares */}
      <div>
        <h3 className="text-xl font-semibold mb-3">Productos similares</h3>
        <div className="grid grid-cols-2 sm:grid-cols-3 md:grid-cols-4 gap-4">
          {data.neighbors.map((n) => (
            <div
              key={n.product_id}
              className="border rounded-lg p-3 shadow bg-white dark:bg-gray-800"
            >
              <img
                src={n.image_url}
                alt={n.name}
                className="w-full h-32 object-contain mb-2"
              />
              <p className="text-sm font-medium">{n.name}</p>
              <p className="text-xs text-gray-500">
                Score: {n.score.toFixed(4)}
              </p>
            </div>
          ))}
        </div>
      </div>
    </div>
  );
}


=== Archivo: .\app\test\product\values\[column]\page.tsx ===

'use client'
import { useEffect, useState } from 'react'
import { useParams } from 'next/navigation'
import { apiFetch } from '../../../../lib/api/client'
import type { DistinctValues } from '../../../../lib/types/product'

export default function ProductValuesPage() {
  const { column } = useParams<{ column: string }>()
  const [data, setData] = useState<DistinctValues | null>(null)
  const [error, setError] = useState<string | null>(null)

  useEffect(() => {
    if (!column) return
    apiFetch<DistinctValues>(`/products/values/${column}`)
      .then(setData)
      .catch(err =>
        setError(err instanceof Error ? err.message : 'Unknown error')
      )
  }, [column])

  if (error) return <div className="p-4 text-red-600">Error: {error}</div>
  if (!data) return <div className="p-4">Cargando valores...</div>

  return (
    <div className="p-4 max-w-2xl mx-auto">
      <h2 className="text-2xl font-bold mb-4">
        Columna: <span className="text-green-600">{data.column}</span>
      </h2>
      <ul className="grid grid-cols-2 sm:grid-cols-3 gap-3">
        {data.values.map((v, i) => (
          <li
            key={i}
            className="border rounded p-2 text-center bg-white dark:bg-gray-800 shadow"
          >
            {v}
          </li>
        ))}
      </ul>
    </div>
  )
}


=== Archivo: .\app\test\product\[id]\page.tsx ===

"use client";
import { useEffect, useState } from "react";
import { useParams } from "next/navigation";
import { apiFetch } from "../../../lib/api/client";
import type { ProductSingle } from "../../../lib/types/product";

export default function ProductPage() {
  const { id } = useParams<{ id: string }>();
  const [product, setProduct] = useState<ProductSingle | null>(null);
  const [error, setError] = useState<string | null>(null);

  useEffect(() => {
    if (!id) return;
    apiFetch<ProductSingle>(`/products/single/${id}`)
      .then(setProduct)
      .catch((err) => setError(err instanceof Error ? err.message : "Unknown error"));
  }, [id]);

  if (error) return <div className="p-4 text-red-600">Error: {error}</div>;
  if (!product) return <div className="p-4">Cargando producto...</div>;

  return (
    <div className="p-4 max-w-md mx-auto">
      <h2 className="text-2xl font-bold mb-4">{product.name}</h2>
      <img
        src={product.image_url}
        alt={product.name}
        className="w-full h-64 object-contain mb-4 border rounded"
      />
      <p><span className="font-semibold">ID:</span> {product.product_id}</p>
      <p><span className="font-semibold">Categor√≠a:</span> {product.category}</p>
    </div>
  );
}


=== Archivo: .\app\test\system\page.tsx ===

"use client";
import { useEffect, useState } from "react";
import { apiFetch } from "../../lib/api/client";

type ApiResponse = Record<string, unknown>;

export default function SystemTestPage() {
  const [health, setHealth] = useState<ApiResponse | null >(null);
  const [dbHealth, setDbHealth] = useState<ApiResponse | null>(null);
  const [error, setError] = useState<string | null>(null);

  useEffect(() => {
    async function fetchData() {
      try {
        const healthData = await apiFetch<ApiResponse>("/health");
        setHealth(healthData);

        const dbData = await apiFetch<ApiResponse>("/db/health");
        setDbHealth(dbData);
      } catch (err) {
        if (err instanceof Error) {
          setError(err.message);
        } else {
          setError("Unknown error");
        }
      }
    }
    fetchData();
  }, []);

  if (error) return <div className="p-4 text-red-600">Error: {error}</div>;
  if (!health || !dbHealth) return <div className="p-4">Cargando...</div>;

  return (
    <div className="p-4 space-y-4">
      <div>
        <h2 className="font-bold text-lg mb-2">System Health</h2>
        <pre className="bg-gray-100 dark:bg-gray-800 p-2 rounded">
          {JSON.stringify(health, null, 2)}
        </pre>
      </div>
      <div>
        <h2 className="font-bold text-lg mb-2">Database Health</h2>
        <pre className="bg-gray-100 dark:bg-gray-800 p-2 rounded">
          {JSON.stringify(dbHealth, null, 2)}
        </pre>
      </div>
    </div>
  );
}


============================================================
Resumen final:
Total de archivos procesados: 37
Total de l√≠neas combinadas: 2842
============================================================
