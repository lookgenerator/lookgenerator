

=== Archivo: .\app\globals.css ===

@tailwind base;
@tailwind components;
@tailwind utilities;

/* Variables CSS personalizadas */
:root {
  --background: #ffffff;
  --foreground: #171717;
}

@media (prefers-color-scheme: dark) {
  :root {
    --background: #0a0a0a;
    --foreground: #ededed;
  }
}

body {
  background: var(--background);
  color: var(--foreground);
  font-family: Arial, Helvetica, sans-serif;
}

.perspective {
  perspective: 1000px;
}
.backface-hidden {
  backface-visibility: hidden;
}

.scrollbar-hide::-webkit-scrollbar {
  display: none;
}
.scrollbar-hide {
  -ms-overflow-style: none;
  scrollbar-width: none;
}


=== Archivo: .\app\layout.tsx ===

import type { Metadata } from "next";
import { Geist, Geist_Mono } from "next/font/google";
import "./globals.css";

const geistSans = Geist({
  variable: "--font-geist-sans",
  subsets: ["latin"],
});

const geistMono = Geist_Mono({
  variable: "--font-geist-mono",
  subsets: ["latin"],
});

export const metadata: Metadata = {
  title: "Create Next App",
  description: "Generated by create next app",
};

export default function RootLayout({
  children,
}: Readonly<{
  children: React.ReactNode;
}>) {
  return (
    <html lang="en">
      <body
        className={`${geistSans.variable} ${geistMono.variable} antialiased`}
      >
        {children}
      </body>
    </html>
  );
}


=== Archivo: .\app\page.tsx ===

import Chat from './components/Chat'

export default function Home() {
  return <Chat />
}


=== Archivo: .\app\api\llm\route.ts ===

import { NextResponse } from 'next/server'
import OpenAI from 'openai'
import { generateGreeting } from './handlers/greetingHandler'
import { generateAuthGreeting } from './handlers/authGreetingHandler'

console.log('‚ö°Ô∏è /api/llm ROUTE ejecut√°ndose en servidor...')

const client = new OpenAI({
  apiKey: process.env.OPENAI_API_KEY!,
})

export async function POST(req: Request) {
  try {
    const { message } = await req.json()

    const prompt = `
Eres un clasificador de intenciones para un chatbot de e-commerce.
Tu √∫nica salida debe ser un JSON v√°lido con el formato:
{"intent": "...", "entities": {...}}

Intenciones posibles:
- identificar_usuario ‚Üí cuando el usuario escribe un n√∫mero de cliente (ej: "soy 12345")
- ver_mas_producto ‚Üí cuando pide ver m√°s detalles de un producto
- recomendaciones_producto ‚Üí cuando pide recomendaciones iguales a un producto
- buscar_por_descripcion ‚Üí cuando quiere buscar algo por descripci√≥n (ej: "buscar zapatillas rojas")
- saludo ‚Üí cuando el usuario saluda (ej: "hola", "buenas")
- desconocido ‚Üí si no encaja con nada

Ejemplos:
Usuario: "hola"  
Respuesta: {"intent":"saludo","entities":{}}

Usuario: "soy el cliente 12345"  
Respuesta: {"intent":"identificar_usuario","entities":{"customer_id":"12345"}}

Usuario: "buscar zapatillas rojas"  
Respuesta: {"intent":"buscar_por_descripcion","entities":{"descripcion":"zapatillas rojas"}}

Mensaje del usuario: "${message}"
`

    const completion = await client.chat.completions.create({
      model: process.env.MODEL || 'no asignado',
      messages: [{ role: 'user', content: prompt }],
      temperature: 0,
    })

    const raw = completion.choices[0].message?.content?.trim() || '{}'

    let parsed
    try {
      parsed = JSON.parse(raw)
    } catch {
      console.error('‚ùå No se pudo parsear:', raw)
      parsed = { intent: 'desconocido', entities: {} }
    }

    // 2Ô∏è‚É£ --- SI ES UN SALUDO, GENERAMOS RESPUESTA PERSONALIZADA ---
    if (parsed.intent === 'saludo') {
      const greeting = await generateGreeting(message)
      return NextResponse.json({
        intent: parsed.intent,
        response: greeting,
        entities: parsed.entities,
      })
    }
    // 2Ô∏è‚É£ --- SI ES IDENTIFICACI√ìN DE USUARIO, GENERAMOS SALLUDO PERSONALIZADO ---
    if (
      parsed.intent === 'identificar_usuario' &&
      parsed.entities?.customer_id
    ) {
      const customerName = parsed.entities?.customer_name || ''
      const greeting = await generateAuthGreeting(customerName)

      return NextResponse.json({
        intent: parsed.intent,
        response: greeting,
        entities: parsed.entities,
      })
    }

    return NextResponse.json(parsed)
  } catch (err) {
    console.error('‚ùå Error en /api/llm:', err)
    return NextResponse.json(
      { intent: 'desconocido', entities: {}, error: 'internal' },
      { status: 500 }
    )
  }
}


=== Archivo: .\app\api\llm\auth-greeting\route.ts ===

import { NextResponse } from "next/server";
import { generateAuthGreeting } from "../handlers/authGreetingHandler";

export async function POST(req: Request) {
  try {
    const { customerName } = await req.json();

    if (!customerName) {
      return NextResponse.json(
        { response: null, error: "customerName required" },
        { status: 400 }
      );
    }

    const greeting = await generateAuthGreeting(customerName);

    return NextResponse.json({ response: greeting });
  } catch (err) {
    console.error("‚ùå Error en /api/llm/auth-greeting:", err);
    return NextResponse.json({ response: null }, { status: 500 });
  }
}


=== Archivo: .\app\api\llm\handlers\authGreetingHandler.ts ===

import OpenAI from "openai";

const client = new OpenAI({
  apiKey: process.env.OPENAI_API_KEY!,
});

export async function generateAuthGreeting(customerName: string) {
  const randomSeed = Math.floor(Math.random() * 10000);

  const prompt = `
Eres un asistente virtual amable de una tienda online.
Tu tarea es generar un mensaje de bienvenida cuando un cliente se autentica.
Debe sonar c√°lido, personalizado y diferente cada vez.
Incluye el nombre del cliente si est√° disponible ("${customerName}").

Var√≠a el estilo, los emojis y las frases para que no se repitan.

Ejemplos:
- "¬°Hola ${customerName}! Me alegra verte de nuevo üíö"
- "¬°Bienvenida otra vez, ${customerName}! ¬øLista para descubrir novedades? üõçÔ∏è"
- "¬°Hey ${customerName}! Qu√© gusto volver a verte üòä"
- "¬°Encantado de verte, ${customerName}! Te he preparado recomendaciones personalizadas üîé"

No incluyas comillas ni texto adicional. Solo devuelve el saludo.
Semilla de variaci√≥n: ${randomSeed}
`;

  const completion = await client.chat.completions.create({
    model: process.env.MODEL || "gpt-4o-mini",
    messages: [{ role: "system", content: prompt }],
    temperature: 1,
    top_p: 1,
    presence_penalty: 0.6,
    frequency_penalty: 0.5,
    max_tokens: 80,
  });

  const greeting = completion.choices[0].message?.content?.trim();
  return greeting || `¬°Hola ${customerName}! Encantado de verte üòä`;
}


=== Archivo: .\app\api\llm\handlers\defaultHandler.ts ===

export async function defaultHandler(message: string) {
  return Response.json({
    intent: "desconocido",
    response: "Perdona, no he entendido bien tu mensaje ü§î. ¬øPodr√≠as reformularlo?",
  });
}


=== Archivo: .\app\api\llm\handlers\greetingHandler.ts ===

import OpenAI from "openai";

const client = new OpenAI({
  apiKey: process.env.OPENAI_API_KEY!,
});

export async function generateGreeting(message: string) {
  const randomSeed = Math.floor(Math.random() * 10000);

  const prompt = `
Eres un asistente virtual amable de una tienda online.
Si el usuario est√° autenticado y el mensaje indica su nombre (ejemplo: "Usuario autenticado: Laura"), debes saludarlo usando su nombre.
Si no hay nombre, genera un saludo general, breve, natural y diferente cada vez.
El saludo debe sonar humano, positivo y cercano.

Var√≠a el estilo y estructura en cada respuesta (usa distintos emojis o frases).

Ejemplos:
- "¬°Hola Laura! Qu√© gusto verte üòä"
- "¬°Buenas, Laura! Encantado de saludarte üëã"
- "¬°Hola! Me alegra verte por aqu√≠ üòÑ"
- "¬°Hey! Espero que est√©s teniendo un gran d√≠a ‚òÄÔ∏è"

Solo devuelve el texto del saludo. No incluyas nada m√°s.
Semilla de variaci√≥n: ${randomSeed}
`;

  const completion = await client.chat.completions.create({
    model: process.env.MODEL || "gpt-4o-mini",
    messages: [
      { role: "system", content: prompt },
      { role: "user", content: message },
    ],
    temperature: 1,
    top_p: 1,
    presence_penalty: 0.6,
    frequency_penalty: 0.5,
    max_tokens: 60,
  });

  const greeting = completion.choices[0].message?.content?.trim();
  return greeting || "¬°Hola! Encantado de saludarte üòä";
}


=== Archivo: .\app\components\Chat.tsx ===

'use client'
import { useState, useRef, useEffect } from 'react'
import Image from 'next/image'
import Message from './Message'
import InputBox from './InputBox'
import TypingIndicator from './TypingIndicator'
import useDarkMode from '../hooks/useDarkMode'
import { Moon, Sun } from 'lucide-react'
import { getProductById, getSimilarProducts } from '../lib/api/products'
import type { ChatProduct, MessageItem } from '../lib/types/chat'
import { getCustomerById } from '../lib/api/client'
import type { Customer } from '../lib/types/customer'
import { User } from 'lucide-react'
import { detectIntent } from '../lib/api/llm'

export default function Chat() {
  const [messages, setMessages] = useState<MessageItem[]>([])
  const chatRef = useRef<HTMLDivElement>(null)
  const [customer, setCustomer] = useState<Customer | null>(null)
  const [isLoading, setIsLoading] = useState(false)
  const inputRef = useRef<HTMLInputElement>(null)

  useEffect(() => {
    if (!isLoading) {
      inputRef.current?.focus()
    }
  }, [isLoading])

  const handleSend = async (msg: string) => {
    setMessages(prev => [...prev, { role: 'user', text: msg }])

    setIsLoading(true)

    try {
      const { intent, entities, response } = await detectIntent(
        customer
          ? `Usuario autenticado: ${customer.first_name}. Mensaje: ${msg}`
          : msg
      )

      // üîé DEBUG solo si NEXT_PUBLIC_DEBUG = "true"
      if (process.env.NEXT_PUBLIC_DEBUG === 'true') {
        setMessages(prev => [
          ...prev,
          {
            role: 'bot',
            text: `üõ†Ô∏è Debug ‚Üí Intent: **${intent}** | Entities: ${JSON.stringify(
              entities
            )}| Response: ${JSON.stringify(response)}`,
          },
        ])
      }

      switch (intent) {
        case 'saludo':
          const name = customer?.first_name ? ` ${customer.first_name}` : ''
          setMessages(prev => [
            ...prev,
            {
              role: 'bot',
              text: response
                ? response
                : `üëã ¬°Hola${name}! ¬øEn qu√© puedo ayudarte hoy?`,
            },
          ])
          break

        case 'identificar_usuario':
          if (entities.customer_id) {
            try {
              const customer = await getCustomerById(
                String(entities.customer_id)
              )
              setCustomer(customer)

              // üîπ Generar saludo LLM de bienvenida personalizada
              const res = await fetch('/api/llm/auth-greeting', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                  customerName: customer.first_name,
                }),
              })
              const { response: authGreeting } = await res.json()

              console.log('authGreeting ', authGreeting)

              setMessages(prev => [
                ...prev,
                {
                  role: 'bot',
                  text:
                    authGreeting ||
                    `¬°Hola ${customer.first_name}! Bienvenido üëã`,
                },
              ])

              if (customer.products && customer.products.length > 0) {
                const baseProduct = customer.products[0]

                setMessages(prev => [
                  ...prev,
                  {
                    role: 'bot',
                    text: `Estos son algunos de tus productos:`,
                    product: {
                      id: baseProduct.product_id,
                      name: baseProduct.name,
                      image_url: baseProduct.image_url,
                      description:
                        'Este es un producto destacado dentro de nuestro cat√°logo. Pr√≥ximamente aqu√≠ aparecer√° una descripci√≥n generada autom√°ticamente por el asistente inteligente.',
                    },
                  },
                ])

                const data = await getSimilarProducts(baseProduct.product_id)
                setMessages(prev => [
                  ...prev,
                  {
                    role: 'bot',
                    text: `Productos similares a ${baseProduct.name}:`,
                    products: data.neighbors.map(p => ({
                      id: p.product_id,
                      name: p.name,
                      image_url: p.image_url,
                      description:
                        'Este es un producto destacado dentro de nuestro cat√°logo. Pr√≥ximamente aqu√≠ aparecer√° una descripci√≥n generada autom√°ticamente por el asistente inteligente.',
                    })),
                  },
                ])
              }
            } catch (err) {
              setMessages(prev => [
                ...prev,
                {
                  role: 'bot',
                  text: `‚ùå No se encontr√≥ un cliente con ese ID. (${err})`,
                },
              ])
            }
          }
          break

        case 'ver_mas_producto':
          setMessages(prev => [
            ...prev,
            {
              role: 'bot',
              text: "Aqu√≠ ir√≠a la l√≥gica de 'ver m√°s producto' üîç",
            },
          ])
          break

        case 'recomendaciones_producto':
          setMessages(prev => [
            ...prev,
            {
              role: 'bot',
              text: 'Aqu√≠ ir√≠a la l√≥gica para dar recomendaciones de producto üí°',
            },
          ])
          break

        case 'buscar_por_descripcion':
          setMessages(prev => [
            ...prev,
            {
              role: 'bot',
              text: `Buscando productos que coincidan con: "${entities.descripcion}" üîé`,
            },
          ])
          break

        default:
          setMessages(prev => [
            ...prev,
            { role: 'bot', text: 'No entend√≠ la petici√≥n ü§î' },
          ])
      }
    } catch (err) {
      console.error('Error detectando intenci√≥n:', err)
      setMessages(prev => [
        ...prev,
        { role: 'bot', text: '‚ùå Error procesando tu mensaje.' },
      ])
    } finally {
      setIsLoading(false)
    }
  }

  useEffect(() => {
    chatRef.current?.scrollTo({
      top: chatRef.current.scrollHeight,
      behavior: 'smooth',
    })
  }, [messages])

  const [darkMode, setDarkMode] = useDarkMode()

  const formatCustomerId = (id: string) => {
    return `600833......${id.padStart(7, '0')}`
  }

  return (
    <div className="flex items-center justify-center h-screen bg-gray-100 dark:bg-gray-900">
      <div className="flex flex-col w-full max-w-md h-[850px] bg-white dark:bg-gray-800 rounded-2xl shadow-lg overflow-hidden">
        {/* Header */}
        <div className="flex items-center gap-3 p-4 bg-green-600 text-white shadow-md dark:bg-green-700">
          <Image
            src="https://upload.wikimedia.org/wikipedia/commons/0/02/Logo_Corte_Ingl%C3%A9s.svg"
            alt="El Corte Ingl√©s"
            width={40}
            height={40}
            className="rounded"
          />
          <h1 className="flex-1 text-2xl font-extrabold tracking-tight">
            Asistente Virtual
          </h1>

          {/* Cliente identificado */}
          {customer && (
            <div className="flex flex-col items-end text-sm">
              <div className="flex items-center gap-2">
                <span className="bg-white/20 p-1 rounded-full">
                  <User size={16} />
                </span>
                <span className="font-semibold">
                  {customer.first_name} {customer.last_name}
                </span>
              </div>
              <span className="text-xs opacity-80">
                {formatCustomerId(customer.customer_id)}
              </span>
            </div>
          )}
          <button
            onClick={() => setDarkMode(!darkMode)}
            className="p-2 rounded-full hover:bg-green-500/20 transition"
          >
            {darkMode ? <Sun size={20} /> : <Moon size={20} />}
          </button>
        </div>

        {/* Chat body */}
        <div
          ref={chatRef}
          className="flex-1 overflow-y-auto p-4 bg-gray-50 dark:bg-gray-900"
        >
          {messages.map((m, i) => (
            <Message
              key={i}
              role={m.role}
              text={m.text}
              product={m.product}
              products={m.products}
            />
          ))}

          {isLoading && (
            <div className="flex justify-start">
              <div className="px-3 py-2 rounded-lg bg-gray-200 dark:bg-gray-700">
                <TypingIndicator />
              </div>
            </div>
          )}
        </div>

        {/* Input */}
        <InputBox
          onSend={handleSend}
          disabled={isLoading}
          inputRef={inputRef}
        />
      </div>
    </div>
  )
}


=== Archivo: .\app\components\InputBox.tsx ===

"use client";
import { useState } from "react";

type Props = {
  onSend: (msg: string) => void;
  disabled?: boolean;
  inputRef?: React.RefObject<HTMLInputElement | null>;
};

export default function InputBox({ onSend, disabled=false, inputRef }: Props) {
  const [text, setText] = useState("");
  
  return (
    <form
      onSubmit={(e) => {
        e.preventDefault();
        if (!text.trim()) return;
        onSend(text);
        setText("");
      }}
      className="flex gap-2 p-3 border-t bg-white dark:bg-gray-800 dark:border-gray-700 sticky bottom-0"
    >
      <input
        ref={inputRef}
        className="flex-1 p-2 border rounded-xl focus:outline-none focus:ring-2 focus:ring-green-500 dark:bg-gray-700 dark:text-white dark:border-gray-600"
        value={text}
        onChange={(e) => setText(e.target.value)}
        placeholder="Escribe un mensaje..."
        disabled={disabled}
      />
      <button
        className="bg-green-500 hover:bg-green-600 text-white px-4 py-2 rounded-xl transition"
        disabled={disabled}
      >
        ‚û§
      </button>
    </form>
  );
}


=== Archivo: .\app\components\Message.tsx ===

import { User, Bot } from 'lucide-react'
import type { ChatProduct } from '../lib/types/chat'
import ProductCard from './ProductCard'
import SimilarProductsGrid from "./SimilarProductsGrid";
import SimilarProductsCarousel from "./SimilarProductsCarousel";

interface Props {
  role: "user" | "bot";
  text: string;
  product?: ChatProduct;
  products?: ChatProduct[]; // üëà importante
}

export default function Message({ role, text, product, products }: Props){
   console.log("Message props:", { text, product, products });
  const isUser = role === 'user'

  return (
    <div
      className={`flex items-end gap-2 mb-3 ${
        isUser ? 'justify-end' : 'justify-start'
      }`}
    >
      {!isUser && (
        <div className="w-8 h-8 flex items-center justify-center rounded-full bg-gray-300">
          <Bot size={18} />
        </div>
      )}

      <div
        className={`px-4 py-2 rounded-2xl shadow max-w-[75%] ${
          isUser
            ? 'bg-green-500 text-white rounded-br-none'
            : 'bg-gray-200 text-gray-900 rounded-bl-none dark:bg-gray-700 dark:text-gray-100'
        }`}
      >
        <p className="mb-2">{text}</p>

        {product && <ProductCard product={product} />}

        {/* m√∫ltiples productos */}
        {/* Grid de varios productos */}
        {products && <SimilarProductsCarousel products={products} />}
      </div>

      {isUser && (
        <div className="w-8 h-8 flex items-center justify-center rounded-full bg-green-500 text-white">
          <User size={18} />
        </div>
      )}
    </div>
  )
}


=== Archivo: .\app\components\ProductCard.tsx ===

"use client";
import { useState, useRef } from "react";
import type { ChatProduct } from "../lib/types/chat";

function DescriptionWithFade({ text }: { text: string }) {
  const [isAtEnd, setIsAtEnd] = useState(false);
  const scrollRef = useRef<HTMLDivElement>(null);

  const handleScroll = () => {
    if (scrollRef.current) {
      const { scrollTop, scrollHeight, clientHeight } = scrollRef.current;
      setIsAtEnd(scrollTop + clientHeight >= scrollHeight - 2);
    }
  };

  return (
    <div className="relative group h-full max-h-24 overflow-hidden">
      <div
        ref={scrollRef}
        onScroll={handleScroll}
        className="text-sm text-gray-700 h-full max-h-24 overflow-y-auto px-1 pr-2
                   scrollbar-thin scrollbar-thumb-gray-400 scrollbar-track-transparent
                   [scrollbar-width:none] group-hover:[scrollbar-width:thin]"
      >
        {text}
      </div>

      {!isAtEnd && (
        <div className="pointer-events-none absolute bottom-0 left-0 w-full h-6 
                        bg-gradient-to-t from-white to-transparent dark:from-gray-800" />
      )}
    </div>
  );
}

export default function ProductCard({ product }: { product: ChatProduct }) {
  const [flipped, setFlipped] = useState(false);

  return (
    <div
      className={`relative transition-all duration-500 ease-in-out ${
        flipped ? "w-full h-[490px]" : "w-48 h-64"
      }`}
    >
      <div
        className={`relative w-full h-full transition-transform duration-500 [transform-style:preserve-3d] ${
          flipped ? "[transform:rotateY(180deg)]" : ""
        }`}
      >
        {/* Cara frontal */}
        <div
          className="absolute inset-0 h-full [backface-visibility:hidden] flex flex-col items-center justify-between 
                     rounded-lg shadow-md bg-white dark:bg-gray-800 overflow-hidden"
        >
          <img
            src={product.image_url}
            alt={product.name}
            className="w-full h-32 object-contain"
          />
          <div className="p-2 text-center">
            <div className="font-medium text-xs text-gray-900 dark:text-gray-100 line-clamp-2">
              {product.name}
            </div>
            <button
              className="mt-2 bg-green-600 text-white px-3 py-1 rounded-md text-xs hover:bg-green-700 transition-colors"
              onClick={() => setFlipped(true)}
            >
              Ver m√°s
            </button>
          </div>
        </div>

        {/* Cara trasera */}
        <div
          className="absolute inset-0 h-full [transform:rotateY(180deg)] [backface-visibility:hidden] 
                     bg-white dark:bg-gray-800 rounded-lg shadow-md flex flex-col"
        >
          {/* Parte superior */}
          <div className="flex-shrink-0 p-4">
            <img
              src={product.image_url}
              alt={product.name}
              className="w-full h-40 object-contain mb-3"
            />
            <h3 className="font-semibold text-lg mb-2">{product.name}</h3>
            {product.category && (
              <p className="text-sm text-gray-600 dark:text-gray-400 mb-1">
                Categor√≠a: {product.category}
              </p>
            )}
            {product.id && (
              <p className="text-xs text-gray-400 mb-2">ID: {product.id}</p>
            )}
          </div>

          {/* Centro ‚Üí descripci√≥n con scroll */}
          <div className="flex-1 px-4">
            <DescriptionWithFade
              text={
                product.description ??
                "Descripci√≥n gen√©rica del producto. Aqu√≠ aparecer√° informaci√≥n extendida cuando se conecte el LLM."
              }
            />
          </div>

          {/* Bot√≥n abajo */}
          <div className="flex-shrink-0 p-4">
            <button
              onClick={() => setFlipped(false)}
              className="w-full bg-gray-600 text-white px-3 py-1 rounded-md text-xs hover:bg-gray-700 transition-colors"
            >
              Volver
            </button>
          </div>
        </div>
      </div>
    </div>
  );
}


=== Archivo: .\app\components\SimilarProductsCarousel.tsx ===

"use client";
import { Swiper, SwiperSlide } from "swiper/react";
import { Navigation, Pagination, EffectCoverflow } from "swiper/modules";

import "swiper/css";
import "swiper/css/navigation";
import "swiper/css/pagination";
import "swiper/css/effect-coverflow";

import ProductCard from "./ProductCard";
import type { ChatProduct } from "../lib/types/chat";

export default function SimilarProductsCarousel({ products }: { products: ChatProduct[] }) {
  if (!products || products.length === 0) {
    return <p className="text-sm text-gray-500">‚ö†Ô∏è No hay productos similares disponibles.</p>;
  }

  return (
    <div className="w-full">
      <Swiper
        modules={[Navigation, Pagination, EffectCoverflow]}
        effect="coverflow"
        grabCursor={true}
        centeredSlides={true}
        slidesPerView={1.5}
        navigation
        pagination={{ clickable: true }}
        coverflowEffect={{
          rotate: 30,   // √°ngulo de rotaci√≥n de las tarjetas
          stretch: 0,   // separaci√≥n entre ellas
          depth: 100,   // profundidad 3D
          modifier: 1,  // intensidad del efecto
          slideShadows: true, // sombras
        }}
        className="py-6"
      >
        {products.map((p) => (
          <SwiperSlide
            key={p.id}
            className="w-56 flex justify-center" // ancho fijo para cada card
          >
            <ProductCard product={p} />
          </SwiperSlide>
        ))}
      </Swiper>
      <style jsx global>{`
  .swiper-pagination {
    bottom: -254px !important; /* desplaza los puntitos hacia abajo */
  }
`}</style>
    </div>
  );
}

=== Archivo: .\app\components\SimilarProductsGrid.tsx ===

"use client";
import ProductCard from "./ProductCard";
import type { ChatProduct } from "../lib/types/chat";

export default function SimilarProductsGrid({ products }: { products: ChatProduct[] }) {
  if (!products || products.length === 0) {
    return <p className="text-sm text-gray-500">‚ö†Ô∏è No hay productos similares disponibles.</p>;
  }

  return (
    <div className="grid grid-cols-2 sm:grid-cols-3 md:grid-cols-4 gap-4 mt-2">
      {products.map((p) => (
        <ProductCard key={p.id} product={p} />
      ))}
    </div>
  );
}


=== Archivo: .\app\components\TypingIndicator.tsx ===

// src/app/components/TypingIndicator.tsx
"use client";

export default function TypingIndicator() {
  return (
    <div className="flex gap-1 items-center">
      <span className="w-2.5 h-2.5 bg-gray-500 dark:bg-gray-300 rounded-full animate-bounce"></span>
      <span className="w-2.5 h-2.5 bg-gray-500 dark:bg-gray-300 rounded-full animate-bounce [animation-delay:150ms]"></span>
      <span className="w-2.5 h-2.5 bg-gray-500 dark:bg-gray-300 rounded-full animate-bounce [animation-delay:300ms]"></span>
    </div>
  );
}


=== Archivo: .\app\hooks\useDarkMode.ts ===

"use client";
import { useEffect, useState } from "react";

export default function useDarkMode() {
  const [enabled, setEnabled] = useState(false);

  useEffect(() => {
    if (enabled) {
      document.documentElement.classList.add("dark");
    } else {
      document.documentElement.classList.remove("dark");
    }
  }, [enabled]);

  return [enabled, setEnabled] as const;
}

=== Archivo: .\app\lib\api\auth.ts ===

const API_URL = process.env.NEXT_PUBLIC_API_URL!
const API_USER = process.env.NEXT_PUBLIC_API_USER!
const API_PASSWORD = process.env.NEXT_PUBLIC_API_PASSWORD!

let token: string | undefined

export async function getToken(): Promise<string> {
  if (token) return token // aqu√≠ TS ya sabe que es string

  const res = await fetch(`${API_URL}/auth/token`, {
    method: 'POST',
    headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
    body: new URLSearchParams({
      username: API_USER,
      password: API_PASSWORD,
    }),
  })

  if (!res.ok) {
    const text = await res.text()
    throw new Error(`Failed to fetch token: ${res.status} ${text}`)
  }

  const data = await res.json()
  token = data.access_token as string

  if (!token) throw new Error('No token returned from API')

  return token
}


=== Archivo: .\app\lib\api\client.ts ===

import { getToken } from './auth'
import type { Customer } from "../types/customer";

const API_URL = process.env.NEXT_PUBLIC_API_URL!

export async function apiFetch<T>(
  endpoint: string,
  options: RequestInit = {}
): Promise<T> {
  const token = await getToken()

  const res = await fetch(`${API_URL}${endpoint}`, {
    ...options,
    headers: {
      ...(options.headers || {}),
      Authorization: `Bearer ${token}`,
      'Content-Type': 'application/json',
    },
  })

  if (!res.ok) {
    const text = await res.text()
    throw new Error(`API error: ${res.status} ${text}`)
  }

  return res.json() as Promise<T>
}

export async function getCustomerById(customerId: string): Promise<Customer> {
  return apiFetch<Customer>(`/customers/${customerId}`);
}

=== Archivo: .\app\lib\api\llm.ts ===

// lib/api/llm.ts
export type Intent =
  | "identificar_usuario"
  | "ver_mas_producto"
  | "recomendaciones_producto"
  | "buscar_por_descripcion"
  | "saludo"
  | "desconocido";

export interface IntentResult {
  intent: Intent;
  entities: Record<string, string | number | boolean>;
  response?: string; // ‚Üê a√±adimos el campo opcional generado por el LLM
  error?: string;    // ‚Üê opcional para capturar errores del backend
}

export async function detectIntent(message: string): Promise<IntentResult> {
  const res = await fetch("/api/llm", {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify({ message }),
  });

  if (!res.ok) {
    throw new Error("Error llamando a /api/llm");
  }

  // El backend puede devolver tambi√©n `response`
  const data = await res.json();
  return data as IntentResult;
}


=== Archivo: .\app\lib\api\products.ts ===

import { apiFetch } from "./client";
import type { ProductSingle } from "../types/product";
import type { SimilarProductsResponse } from "../types/product";

export async function getProductById(id: string | number) {
  return apiFetch<ProductSingle>(`/products/single/${id}`);
}

export async function getSimilarProducts(id: string | number) {
  return apiFetch<SimilarProductsResponse>(`/products/similar/${id}`);
}

=== Archivo: .\app\lib\types\chat.ts ===

export type ChatRole = "user" | "bot";

export interface ChatProduct {
  id: number;
  name: string;
  image_url: string;
  category?: string;
  description:
        "Este es un producto destacado dentro de nuestro cat√°logo. Pr√≥ximamente aqu√≠ aparecer√° una descripci√≥n generada autom√°ticamente por el asistente inteligente.",
}

export interface MessageItem {
  role: ChatRole;
  text: string;
  product?: ChatProduct;
  products?: ChatProduct[];
}

=== Archivo: .\app\lib\types\customer.ts ===

export interface Product {
  product_id: number;
  name: string;
  image_url: string;
}

export interface Customer {
  customer_id: string;
  first_name: string;
  last_name: string;
  products: Product[];
}


=== Archivo: .\app\lib\types\product.ts ===

export interface ProductSingle {
  product_id: number;
  name: string;
  category: string;
  image_url: string;
}

export interface ProductNeighbor {
  product_id: number;
  name: string;
  image_url: string;
  score: number;
}

export interface SimilarProductsResponse {
  base_product: {
    product_id: number;
    name: string;
    image_url: string;
  };
  neighbors: ProductNeighbor[];
}

export interface ProductFilter {
  product_id: number;
  name: string;
  category: string;
  image_url: string;
  gender: string;
  mastercategory: string;
  subcategory: string;
  articletype: string;
  basecolour: string;
  season: string;
  year: number;
  usage: string;
}

export interface DistinctValues {
  column: string;
  values: string[];
}

export interface SimilarProductsResponse {
  base_product: {
    product_id: number;
    name: string;
    image_url: string;
  };
  neighbors: ProductNeighbor[];
}

=== Archivo: .\app\test\page.tsx ===

"use client";
import { useEffect, useState } from "react";
import { apiFetch } from "../lib/api/client";

export default function TestPage() {
  const [data, setData] = useState<Record<string, unknown> | null>(null);
  const [error, setError] = useState<string | null>(null);

  useEffect(() => {
    apiFetch<Record<string, unknown>>("/info")
      .then(setData)
      .catch((err) => setError(err.message));
  }, []);

  if (error) return <div className="p-4 text-red-600">Error: {error}</div>;
  if (!data) return <div className="p-4">Cargando...</div>;

  return (
    <pre className="p-4 bg-gray-100 rounded">
      {JSON.stringify(data, null, 2)}
    </pre>
  );
}


=== Archivo: .\app\test\customer\[id]\page.tsx ===

'use client'
import { useEffect, useState } from 'react'
import { useParams } from 'next/navigation'
import { apiFetch } from '../../../lib/api/client'
import type { Customer } from '../../../lib/types/customer'

export default function CustomerPage() {
  const { id } = useParams<{ id: string }>()
  const [customer, setCustomer] = useState<Customer | null>(null)
  const [error, setError] = useState<string | null>(null)

  useEffect(() => {
    if (!id) return
    apiFetch<Customer>(`/customers/${id}`)
      .then(setCustomer)
      .catch(err =>
        setError(err instanceof Error ? err.message : 'Unknown error')
      )
  }, [id])

  if (error) return <div className="p-4 text-red-600">Error: {error}</div>
  if (!customer) return <div className="p-4">Cargando cliente...</div>

  return (
    <div className="p-4 space-y-4">
      <h2 className="text-xl font-bold">
        Cliente: {customer.first_name} {customer.last_name} (ID:{' '}
        {customer.customer_id})
      </h2>

      <h3 className="text-lg font-semibold">Productos:</h3>
      <ul className="grid grid-cols-1 sm:grid-cols-2 gap-4">
        {customer.products.map(p => (
          <li
            key={p.product_id}
            className="border rounded-lg p-3 shadow bg-white dark:bg-gray-800"
          >
            <img
              src={p.image_url}
              alt={p.name}
              className="w-full h-32 object-contain mb-2"
            />
            <p className="font-medium">{p.name}</p>
          </li>
        ))}
      </ul>
    </div>
  )
}


=== Archivo: .\app\test\product\filter\page.tsx ===

"use client";
import { useEffect, useState } from "react";
import { apiFetch } from "../../../lib/api/client";
import type { ProductFilter } from "../../../lib/types/product";

export default function ProductFilterPage() {
  const [products, setProducts] = useState<ProductFilter[]>([]);
  const [error, setError] = useState<string | null>(null);

  // filtros din√°micos
  const filters: Record<string, string> = {
    gender: "Men",
    basecolour: "black",
    limit: "10",
  };

  useEffect(() => {
    async function fetchData() {
      try {
        const query = new URLSearchParams(filters).toString();
        const data = await apiFetch<ProductFilter[]>(`/products/filter?${query}`);
        setProducts(data);
      } catch (err) {
        setError(err instanceof Error ? err.message : "Unknown error");
      }
    }
    fetchData();
  }, []);

  if (error) return <div className="p-4 text-red-600">Error: {error}</div>;
  if (!products.length) return <div className="p-4">Cargando productos...</div>;

  return (
    <div className="p-4 space-y-4 max-w-6xl mx-auto">
      <h2 className="text-2xl font-bold mb-4">Resultados del filtro</h2>
      <div className="grid grid-cols-2 sm:grid-cols-3 md:grid-cols-4 lg:grid-cols-5 gap-4">
        {products.map((p) => (
          <div
            key={p.product_id}
            className="border rounded-lg p-3 shadow bg-white dark:bg-gray-800"
          >
            <img
              src={p.image_url}
              alt={p.name}
              className="w-full h-32 object-contain mb-2"
            />
            <p className="text-sm font-medium">{p.name}</p>
            <p className="text-xs text-gray-500">
              {p.mastercategory} ‚Ä¢ {p.basecolour}
            </p>
            <p className="text-xs text-gray-400">
              {p.season} {p.year} ‚Äî {p.usage}
            </p>
          </div>
        ))}
      </div>
    </div>
  );
}


=== Archivo: .\app\test\product\similar\[id]\page.tsx ===

"use client";
import { useEffect, useState } from "react";
import { useParams } from "next/navigation";
import { apiFetch } from "../../../../lib/api/client";
import type { SimilarProductsResponse } from "../../../../lib/types/product";

export default function SimilarProductsPage() {
  const { id } = useParams<{ id: string }>();
  const [data, setData] = useState<SimilarProductsResponse | null>(null);
  const [error, setError] = useState<string | null>(null);

  useEffect(() => {
    if (!id) return;
    apiFetch<SimilarProductsResponse>(`/products/similar/${id}`)
      .then(setData)
      .catch((err) =>
        setError(err instanceof Error ? err.message : "Unknown error")
      );
  }, [id]);

  if (error) return <div className="p-4 text-red-600">Error: {error}</div>;
  if (!data) return <div className="p-4">Cargando productos similares...</div>;

  return (
    <div className="p-4 space-y-6 max-w-4xl mx-auto">
      {/* Producto base */}
      <div className="text-center">
        <h2 className="text-2xl font-bold mb-2">Producto base</h2>
        <img
          src={data.base_product.image_url}
          alt={data.base_product.name}
          className="w-40 h-40 object-contain mx-auto mb-2"
        />
        <p className="font-medium">{data.base_product.name}</p>
      </div>

      {/* Productos similares */}
      <div>
        <h3 className="text-xl font-semibold mb-3">Productos similares</h3>
        <div className="grid grid-cols-2 sm:grid-cols-3 md:grid-cols-4 gap-4">
          {data.neighbors.map((n) => (
            <div
              key={n.product_id}
              className="border rounded-lg p-3 shadow bg-white dark:bg-gray-800"
            >
              <img
                src={n.image_url}
                alt={n.name}
                className="w-full h-32 object-contain mb-2"
              />
              <p className="text-sm font-medium">{n.name}</p>
              <p className="text-xs text-gray-500">
                Score: {n.score.toFixed(4)}
              </p>
            </div>
          ))}
        </div>
      </div>
    </div>
  );
}


=== Archivo: .\app\test\product\values\[column]\page.tsx ===

'use client'
import { useEffect, useState } from 'react'
import { useParams } from 'next/navigation'
import { apiFetch } from '../../../../lib/api/client'
import type { DistinctValues } from '../../../../lib/types/product'

export default function ProductValuesPage() {
  const { column } = useParams<{ column: string }>()
  const [data, setData] = useState<DistinctValues | null>(null)
  const [error, setError] = useState<string | null>(null)

  useEffect(() => {
    if (!column) return
    apiFetch<DistinctValues>(`/products/values/${column}`)
      .then(setData)
      .catch(err =>
        setError(err instanceof Error ? err.message : 'Unknown error')
      )
  }, [column])

  if (error) return <div className="p-4 text-red-600">Error: {error}</div>
  if (!data) return <div className="p-4">Cargando valores...</div>

  return (
    <div className="p-4 max-w-2xl mx-auto">
      <h2 className="text-2xl font-bold mb-4">
        Columna: <span className="text-green-600">{data.column}</span>
      </h2>
      <ul className="grid grid-cols-2 sm:grid-cols-3 gap-3">
        {data.values.map((v, i) => (
          <li
            key={i}
            className="border rounded p-2 text-center bg-white dark:bg-gray-800 shadow"
          >
            {v}
          </li>
        ))}
      </ul>
    </div>
  )
}


=== Archivo: .\app\test\product\[id]\page.tsx ===

"use client";
import { useEffect, useState } from "react";
import { useParams } from "next/navigation";
import { apiFetch } from "../../../lib/api/client";
import type { ProductSingle } from "../../../lib/types/product";

export default function ProductPage() {
  const { id } = useParams<{ id: string }>();
  const [product, setProduct] = useState<ProductSingle | null>(null);
  const [error, setError] = useState<string | null>(null);

  useEffect(() => {
    if (!id) return;
    apiFetch<ProductSingle>(`/products/single/${id}`)
      .then(setProduct)
      .catch((err) => setError(err instanceof Error ? err.message : "Unknown error"));
  }, [id]);

  if (error) return <div className="p-4 text-red-600">Error: {error}</div>;
  if (!product) return <div className="p-4">Cargando producto...</div>;

  return (
    <div className="p-4 max-w-md mx-auto">
      <h2 className="text-2xl font-bold mb-4">{product.name}</h2>
      <img
        src={product.image_url}
        alt={product.name}
        className="w-full h-64 object-contain mb-4 border rounded"
      />
      <p><span className="font-semibold">ID:</span> {product.product_id}</p>
      <p><span className="font-semibold">Categor√≠a:</span> {product.category}</p>
    </div>
  );
}


=== Archivo: .\app\test\system\page.tsx ===

"use client";
import { useEffect, useState } from "react";
import { apiFetch } from "../../lib/api/client";

type ApiResponse = Record<string, unknown>;

export default function SystemTestPage() {
  const [health, setHealth] = useState<ApiResponse | null >(null);
  const [dbHealth, setDbHealth] = useState<ApiResponse | null>(null);
  const [error, setError] = useState<string | null>(null);

  useEffect(() => {
    async function fetchData() {
      try {
        const healthData = await apiFetch<ApiResponse>("/health");
        setHealth(healthData);

        const dbData = await apiFetch<ApiResponse>("/db/health");
        setDbHealth(dbData);
      } catch (err) {
        if (err instanceof Error) {
          setError(err.message);
        } else {
          setError("Unknown error");
        }
      }
    }
    fetchData();
  }, []);

  if (error) return <div className="p-4 text-red-600">Error: {error}</div>;
  if (!health || !dbHealth) return <div className="p-4">Cargando...</div>;

  return (
    <div className="p-4 space-y-4">
      <div>
        <h2 className="font-bold text-lg mb-2">System Health</h2>
        <pre className="bg-gray-100 dark:bg-gray-800 p-2 rounded">
          {JSON.stringify(health, null, 2)}
        </pre>
      </div>
      <div>
        <h2 className="font-bold text-lg mb-2">Database Health</h2>
        <pre className="bg-gray-100 dark:bg-gray-800 p-2 rounded">
          {JSON.stringify(dbHealth, null, 2)}
        </pre>
      </div>
    </div>
  );
}


============================================================
Resumen final:
Total de archivos procesados: 30
Total de l√≠neas combinadas: 1387
============================================================
